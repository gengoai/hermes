<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="GengoAI">
<title>Hermes Architecture and User Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Hermes Architecture and User Guide</h1>
<div class="details">
<span id="author" class="author">GengoAI</span><br>
<span id="revnumber">version v1.0,</span>
<span id="revdate">February 26, 2020</span>
<br><span id="revremark">Initial Release</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_overview">1. Overview</a></li>
<li><a href="#_installation">2. Installation</a></li>
<li><a href="#_core_classes">3. Core Classes</a>
<ul class="sectlevel2">
<li><a href="#annotatable">3.1. AnnotatableType</a>
<ul class="sectlevel3">
<li><a href="#attribute_type">3.1.1. AttributeType</a></li>
<li><a href="#annotation_type">3.1.2. AnnotationType</a></li>
<li><a href="#relation_type">3.1.3. RelationType</a></li>
<li><a href="#_annotators">3.1.4. Annotators</a></li>
</ul>
</li>
<li><a href="#hstring">3.2. HString</a></li>
<li><a href="#annotations">3.3. Annotation</a>
<ul class="sectlevel3">
<li><a href="#_creating_annotations">3.3.1. Creating Annotations</a></li>
<li><a href="#tags">3.3.2. Tags</a></li>
<li><a href="#_core_annotations">3.3.3. Core Annotations</a></li>
</ul>
</li>
<li><a href="#relations">3.4. Relation</a>
<ul class="sectlevel3">
<li><a href="#_dependency_relations">3.4.1. Dependency Relations</a></li>
<li><a href="#_relation_graphs">3.4.2. Relation Graphs</a></li>
</ul>
</li>
<li><a href="#document">3.5. Document</a>
<ul class="sectlevel3">
<li><a href="#_creating_documents">3.5.1. Creating Documents</a></li>
<li><a href="#_working_with_documents">3.5.2. Working with Documents</a></li>
</ul>
</li>
<li><a href="#corpus">3.6. Document Collections and Corpora</a>
<ul class="sectlevel3">
<li><a href="#_document_formats">3.6.1. Document Formats</a></li>
<li><a href="#_document_collection_creation">3.6.2. Document Collection Creation</a></li>
<li><a href="#_working_with_document_collections_and_corpora">3.6.3. Working with Document Collections and Corpora</a>
<ul class="sectlevel4">
<li><a href="#_accessing_documents">Accessing Documents</a></li>
<li><a href="#_manipulating_the_corpus_and_its_documents">Manipulating the Corpus and its Documents</a></li>
<li><a href="#_querying">Querying</a></li>
<li><a href="#fa">Frequency Analysis</a></li>
<li><a href="#_extracting_n_grams">Extracting N-Grams</a></li>
<li><a href="#_sampling">Sampling</a></li>
<li><a href="#_grouping">Grouping</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#extraction">4. Text Mining</a>
<ul class="sectlevel2">
<li><a href="#lexicons">4.1. Lexicons</a>
<ul class="sectlevel3">
<li><a href="#_reading_and_writing_lexicons">4.1.1. Reading and Writing Lexicons</a></li>
<li><a href="#_word_lists">4.1.2. Word Lists</a></li>
</ul>
</li>
<li><a href="#lyre">4.2. Lyre Expression Language</a>
<ul class="sectlevel3">
<li><a href="#_lyre_syntax">4.2.1. Lyre Syntax</a>
<ul class="sectlevel4">
<li><a href="#_this">This</a></li>
<li><a href="#_literals">Literals</a></li>
<li><a href="#_lists">Lists</a></li>
<li><a href="#_operators">Operators</a></li>
<li><a href="#_conditional_statements">Conditional Statements</a></li>
<li><a href="#_predicates">Predicates</a></li>
<li><a href="#_transforms">Transforms</a></li>
<li><a href="#_annotatabletype_accessors">AnnotatableType Accessors</a></li>
<li><a href="#_lexicons_and_word_lists">Lexicons and Word Lists</a></li>
<li><a href="#_feature_and_count_generators">Feature and Count Generators</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#keywords">4.3. Keyword Extraction</a></li>
<li><a href="#tokenre">4.4. Token-Based Regular Expressions</a>
<ul class="sectlevel3">
<li><a href="#_regular_expression_syntax">4.4.1. Regular Expression Syntax</a>
<ul class="sectlevel4">
<li><a href="#_content_matching">Content Matching</a></li>
<li><a href="#_word_classes">Word Classes</a></li>
<li><a href="#_attributes">Attributes</a></li>
<li><a href="#_annotations">Annotations</a></li>
<li><a href="#_relations">Relations</a></li>
<li><a href="#_greedy_qualifiers">Greedy Qualifiers</a></li>
<li><a href="#_logical_operators">Logical Operators</a></li>
<li><a href="#_special_constructs">Special Constructs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#caduceus">4.5. Caduceus</a>
<ul class="sectlevel3">
<li><a href="#_rule_processing_and_execution">4.5.1. Rule Processing and Execution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_machine_learning">5. Machine Learning</a></li>
<li><a href="#workflows">6. Workflows</a>
<ul class="sectlevel2">
<li><a href="#_contexts">6.1. Contexts</a></li>
<li><a href="#_actions">6.2. Actions</a></li>
<li><a href="#_defining_a_workflow">6.3. Defining a Workflow</a></li>
</ul>
</li>
<li><a href="#hermes_applications">7. Hermes Applications</a>
<ul class="sectlevel2">
<li><a href="#workflow_runner">7.1. Workflow Runner</a></li>
<li><a href="#_annotate">7.2. annotate</a></li>
<li><a href="#_csv2lexicon">7.3. csv2Lexicon</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock text-center">
<div class="content">
<img src="images/hermes.png" alt="hermes">
</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/gengoai.png" alt="gengoai" width="150px">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview"><a class="link" href="#_overview">1. Overview</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hermes is a Natural Language Processing framework for Java inspired by the <a href="http://cs.nyu.edu/cs/faculty/grishman/tipster.html">Tipster Architecture</a>  and licensed under the <a href="http://cs.nyu.edu/cs/faculty/grishman/tipster.html">Apache License, Version 2.0</a> making it free for all uses.
The goal of Hermes is to ease the development and use of NLP technologies by providing easy access to and construction of linguistic annotations on documents using multiple cores or multiple machines (using <a href="http://spark.apache.org/">Apache Spark</a>).
Hermes is designed to aid users in analyzing large textual data sources making it easy define and perform complex workflows to extract, analyze, aggregate, and distill information and knowledge.
Conceptually, text in Hermes is represented as a <a href="#hstring">HString</a> (short for Hermes String) which is a <em>CharSequence</em> that provides access to the:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Overlapping or enclosed annotations.</p>
</li>
<li>
<p>Attributes defining aspects of the text.</p>
</li>
<li>
<p>Relations to other HStrings in the same document.</p>
</li>
<li>
<p>Character offsets within the document</p>
</li>
<li>
<p>Spatial relations (e.g. overlaps, encloses) with other HStrings.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>HStrings can be easily manipulated in a fluent manner or by using Lyre a robust extraction and transformation language that facilitates extraction, filtering, feature generation, counting, and transformation into other objects.
Additionally, Hermes provides extraction based on:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lexicons</p>
</li>
<li>
<p>Token-based regular expressions</p>
</li>
<li>
<p>Machine Learning</p>
</li>
<li>
<p>Trigger-based matching via the Caduceus relation-extraction relation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Throughout Hermes data can be stored and processed in-memory, on-disk, or distributed.
This combination facilitates working with corpora of all sizes.
Additionally, Hermes is tightly integrated with GengoAI’s <a href="https://github.com/gengoai/apollo">Apollo</a> machine learning framework allowing easy training of ml models, including word embeddings (e.g. Glove and Word2Vec), topics (Latent Dirichlet Allocation), and supervised classification of attributes (e.g. sentiment, part-of-speech).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_installation"><a class="link" href="#_installation">2. Installation</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hermes requires Java 11+ and is available via the maven central repository at:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
     <span class="tag">&lt;groupId&gt;</span>com.gengoai<span class="tag">&lt;/groupId&gt;</span>
     <span class="tag">&lt;artifactId&gt;</span>hermes<span class="tag">&lt;/artifactId&gt;</span>
     <span class="tag">&lt;version&gt;</span>1.0<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, you can download a Hermes distribution, which provides easy access to a number of command line and gui applications for processing, annotating, and performing analytics over documents and corpora.
We provide two distributions:</p>
</div>
<table class="tableblock frame-all grid-rows stripes-odd stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local Mode - No Spark</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://download.com" class="bare">http://download.com</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><em>Run Hermes local to one computer or bring your own Spark cluster.</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local Mode - No Spark</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">Run Hermes local to one computer or with Spark in Standalone mode. Also have the option of running on your own Spark Cluster.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>As part of these distributions there are a series of scripts to aid in running Hermes applications (listed in section <a href="#hermes_applications">Hermes Applications</a>) and for running within a distributed Spark environment.</p>
</div>
<div class="paragraph">
<p>Hermes stores its data in a resources directory defined in configuration via <code>hermes.resources.dir</code>.
By default this will be set to the <code>hermes</code> directory under the user&#8217;s home directory, e.g. <code>/home/user/hermes/</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_core_classes"><a class="link" href="#_core_classes">3. Core Classes</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The core classes in Hermes consist of <em>AnnotatableType</em>, <em>AttributeType</em>, <em>AnnotationType</em>, <em>RelationType</em>, <em>HString</em>, <em>Annotation</em>, <em>Document</em>, <em>Relation</em>, <em>Attribute</em>, and <em>Corpus</em>.
How the core clases are composed and inherit from one another is depicted in the following diagram.</p>
</div>
<div id="img-classdigram" class="imageblock">
<div class="content">
<img src="images/class_diagram.png" alt="class diagram">
</div>
<div class="title">Figure 1. Diagram of Herme&#8217;s Core Class</div>
</div>
<div class="sect2">
<h3 id="annotatable"><a class="link" href="#annotatable">3.1. AnnotatableType</a></h3>
<div class="paragraph">
<p>An annotatable type is a type added to documents through the act of annotation.
Annotation can be performed on a corpus of documents or a single document.
Hermes supports the following Annotatable Types:</p>
</div>
<div class="sect3">
<h4 id="attribute_type"><a class="link" href="#attribute_type">3.1.1. AttributeType</a></h4>
<div class="paragraph">
<p>An AttributeType defines a <strong>named</strong> Attribute that can be added to an HString.
Each AttributeType has an associated value type which defines the class of value that the attribute accepts and is specified using Java Generics as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AttributeType&lt;<span class="predefined-type">String</span>&gt; AUTHOR = AttributeType.make(<span class="string"><span class="delimiter">&quot;</span><span class="content">AUTHOR</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">String</span>.class);
AttributeType&lt;<span class="predefined-type">Set</span>&lt;BasicCategories&gt;&gt; CATEGORIES = AttributeType.make(<span class="string"><span class="delimiter">&quot;</span><span class="content">CATEGORIES</span><span class="delimiter">&quot;</span></span>, parameterizedType(<span class="predefined-type">Set</span>.class,BasicCategories.class))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Annotating for AttributeType adds the attribute and value to an annotation or document.
For example, when annotating for the AttributeType PART_OF_SPEECH, each token annotation has a POS value set for its PART_OF_SPEECH attribute of.
Many <a href="#annotation_type">AnnotationType</a> will include attributes when being annotated, e.g. token annotations provide TOKEN_TYPE and CATEGORY attributes.</p>
</div>
</div>
<div class="sect3">
<h4 id="annotation_type"><a class="link" href="#annotation_type">3.1.2. AnnotationType</a></h4>
<div class="paragraph">
<p>An AnnotationType defines an <a href="#annotations">Annotation</a>, which is a <strong>typed</strong> (e.g. token, sentence, phrase chunk) span of text on a document having a defined set of attributes and relations.
AnnotationTypes are hierarchical meaning that each type has a parent (<em>ANNOTATION</em> by default) and can have subtypes.
Additionally, each AnnotationType has an associated <a href="#tags">Tag</a> attribute type, which represents the central attribute of the annotation type (e.g. entity type for entities and part-of-speech for tokens.).
By default, an annotation&#8217;s tag type is inherited from the parent or defined as being a StringTag.
The following code snippet illustrates creating a simple AnnotationType with the default parent and a and an AnnotationType whose parent is <em>ENTITY</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* Assume that SENSE_TAG is a predefined AttributeType */</span>
AnnotationType WORD_SENSE = AnnotationType.make(<span class="string"><span class="delimiter">&quot;</span><span class="content">WORD_SENSE</span><span class="delimiter">&quot;</span></span>, SENSE_TAG);
<span class="comment">/* MY_ENTITY will be a type of ENTITY and have an ENTITY_TYPE tag attribute inherited from ENTITY  */</span>
AnnotationType MY_ENTITY = AnnotationType.make(ENTITY, <span class="string"><span class="delimiter">&quot;</span><span class="content">MY_ENTITY</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="relation_type"><a class="link" href="#relation_type">3.1.3. RelationType</a></h4>
<div class="paragraph">
<p>A RelationType defines the type of arbitrary link, i.e. relation, between two HStrings.
Relation types can define such things as co-reference and syntactic and semantic structure.
Defining a RelationType is performed as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">RelationType</span> AGENT = <span class="predefined-type">RelationType</span>.make(<span class="string"><span class="delimiter">&quot;</span><span class="content">AGENT</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/dep-example.png.png" alt="dep example.png" width="300px" height="154">
</div>
<div class="title">Figure 2. Pictorial example of annotating an AGENT relation from <em>Jim</em> to <em>moved</em>.</div>
</div>
<div class="paragraph">
<p>Annotating for RelationType adds a <a href="#relations">Relation</a> object on the source and target annotation as an <em>outgoing</em> and <em>incoming</em> annotation respectively.
For example, if we had a token <em>Jim</em> as the agent of the verb <em>moved</em>, and annotated for the <em>AGENT</em> RelationType we would add an outgoing <em>AGENT</em> relation on <em>JIM</em> with <em>moved</em> as the target and an incoming <em>AGENT</em> relation on <em>moved</em> with <em>JIM</em> as the source.
Pictorial this would be represented as follows:</p>
</div>
</div>
<div class="sect3">
<h4 id="_annotators"><a class="link" href="#_annotators">3.1.4. Annotators</a></h4>
<div class="paragraph">
<p>Annotator(s) satisfy, i.e. provide, one or more AnnotatableType (<a href="#annotation_type">AnnotationType</a>, <a href="#attribute_type">AttributeType</a>, or <a href="#relation_type">RelationType</a>) by processing a document and adding a new or modifying an existing annotation.
In order to provide the new AnnotatableType an annotator may require one or more AnnotatableType to be present on the document.
For example, an annotator providing the PHRASE_CHUNK AnnotationType would require the presence of the TOKEN AnnotationType and PART_OF_SPEECH AttributeType.
When annotation is complete, the AnnotatableType is marked as complete on the document and an annotator provided version is associated with the type.</p>
</div>
<div class="paragraph">
<p><strong>Sentence Level Annotators</strong>: Sentence level annotators work on individual sentences.
They have a minimum requirement of SENTENCE and TOKEN AnnotationType.
Additional types can be specified by overriding the <code>furtherRequires</code> method.
Sentence level annotators are a convenience when creating annotators that work over or within single sentences.</p>
</div>
<div class="paragraph">
<p><strong>Sub Type Annotators</strong>: In certain cases, such as Named Entity Recognition, there may exist a number of different methodologies which we want to combine to satisfy a parent AnnotationType.
In these situations a SubTypeAnnotator can be used.
A SubTypeAnnotator satisfies an AnnotationType by calling multiple other annotators that satisfy one or more of its sub types.
For example, the EntityAnnotator provides the ENTITY AnnotationType, by using sub annotators which could be a combination of rule-based and machine learning-based methods.</p>
</div>
<div class="paragraph">
<p><strong>Annotator Configuration</strong>: Annotators are not normally created and used directly, but instead are automatically constructed and used when making a call to the <code>annotate</code> methods either on a document or corpus.
AnnotatableType define the annotator that should be constructed as follows:</p>
</div>
<table class="tableblock frame-all grid-rows stripes-odd stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>1. Check if a configuration setting is defined for the type</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>TYPE.LANGUAGE.LABEL.annotator</p>
</li>
<li>
<p>TYPE.LABEL.annotator</p>
</li>
<li>
<p>TYPE.LABEL.annotator.LANGUAGE</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>where <em>TYPE</em> is one of <code>Annotation</code>, <code>Attribute</code>, <code>Relation</code>, <em>LANGUAGE</em> is the language of the document either in its full form, or ISO code, and <em>LABEL</em> is the label (name) of the type. Examples of each are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Annotation.ENGLISH.ENTITY.annotator = com.mycompany.EntityAnnotator</p>
</li>
<li>
<p>Annotation.ENTITY.annotator = com.mycompany.EntityAnnotator</p>
</li>
<li>
<p>Annotation.ENTITY.ENGLISH.annotator = com.mycompany.EntityAnnotator</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-rows stripes-odd stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>2. Check for default implementations</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>com.gengoai.hermes.LANGUAGE_CODE[LowerCase].LANGUAGE_CODE[UpperCase] +  LABEL[CamelCase] + "Annotator"</p>
</li>
<li>
<p>com.gengoai.hermes.annotator."Default" + LANGUAGE_NAME[CamelCase] +  LABEL[CamelCase] + "Annotator"</p>
</li>
<li>
<p>com.gengoai.hermes.annotator."Default" + LABEL[CamelCase] + "Annotator"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>where <em>LANGUAGE_CODE</em> is the ISO code of the document language, <em>LANGUAGE_NAME</em> is the name of the document&#8217;s language, and <em>LABEL</em> is the label (name) of the type. Examples of each are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>com.gengoai.hermes.en.ENEntityAnnotator</p>
</li>
<li>
<p>com.gengoai.hermes.annotator.DefaultEnglishDependencyAnnotator</p>
</li>
<li>
<p>com.gengoai.hermes.annotator.DefaultDependencyAnnotator</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>An example configuration defining a <em>REGEX_ENTITY</em> AnnotationType is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json"><span class="error">A</span><span class="error">n</span><span class="error">n</span><span class="error">o</span><span class="error">t</span><span class="error">a</span><span class="error">t</span><span class="error">i</span><span class="error">o</span><span class="error">n</span> {
     <span class="error">R</span><span class="error">E</span><span class="error">G</span><span class="error">E</span><span class="error">X</span><span class="error">_</span><span class="error">E</span><span class="error">N</span><span class="error">T</span><span class="error">I</span><span class="error">T</span><span class="error">Y</span> {
          <span class="error">E</span><span class="error">N</span><span class="error">G</span><span class="error">L</span><span class="error">I</span><span class="error">S</span><span class="error">H</span> <span class="error">=</span> <span class="error">@</span>{<span class="error">E</span><span class="error">N</span><span class="error">G</span><span class="error">L</span><span class="error">I</span><span class="error">S</span><span class="error">H</span><span class="error">_</span><span class="error">E</span><span class="error">N</span><span class="error">T</span><span class="error">I</span><span class="error">T</span><span class="error">Y</span><span class="error">_</span><span class="error">R</span><span class="error">E</span><span class="error">G</span><span class="error">E</span><span class="error">X</span>} <i class="conum" data-value="1"></i><b>(1)</b>
          <span class="error">J</span><span class="error">A</span><span class="error">P</span><span class="error">A</span><span class="error">N</span><span class="error">E</span><span class="error">S</span><span class="error">E</span> <span class="error">=</span> <span class="error">@</span>{<span class="error">J</span><span class="error">A</span><span class="error">P</span><span class="error">A</span><span class="error">N</span><span class="error">E</span><span class="error">S</span><span class="error">E</span><span class="error">_</span><span class="error">E</span><span class="error">N</span><span class="error">T</span><span class="error">I</span><span class="error">T</span><span class="error">Y</span><span class="error">_</span><span class="error">R</span><span class="error">E</span><span class="error">G</span><span class="error">E</span><span class="error">X</span>} <i class="conum" data-value="2"></i><b>(2)</b>
     }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Points to a Java Bean named <em>ENGLISH_ENTITY_REGEX</em> defined in configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Points to a Java Bean named <em>JAPANESE_ENTITY_REGEX</em> defined in configuration.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="💡"></i>
</td>
<td class="content">
For more information on <strong>Configuration</strong> in Hermes, see the Configuration Section of the Mango User Document.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hstring"><a class="link" href="#hstring">3.2. HString</a></h3>
<div class="paragraph">
<p>An HString (Hermes String) is a Java String on steroids.
It represents the base type of all Hermes text objects.
Every HString has an associated span denoting its starting and ending character offset within the document.
HStrings implement the CharSequence interface allowing them to be used in many of Java&#8217;s builtin String methods and they have similar methods as found on Java Strings.
Importantly, methods not modifying the underlying string, e.g. substring and find, return an HString whereas methods that modify the string, e.g. toLowerCase, return a String object.
The String-Like operations are as follows:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 50.0001%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>charAt(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the character at the given index in the HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>contains(CharSequence)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns true if the given CharSequence is a substring of the HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>contentEquals(CharSequence)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns true if the given CharSequence is equal to the string form of the HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>contentEqualsIgnoreCase(CharSequence)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns true if the given CharSequence is equal to the string form of the HString regardless of case.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>endsWith(CharSequence)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns true if the HString ends with the given CharSequence.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Language</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>getLanguage()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the Language that the HString is written in.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>length()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The length in characters of the HString</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>find(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Finds the given text in this HString starting from the beginning of this HString. If the document is annotated with tokens, the match will extend to the token(s) covering the match.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>find(String, int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Finds the given text in this HString starting from the given start index of this HString. If the document is annotated with tokens, the match will extend to the token(s) covering the match.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream&lt;HString&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>findAll(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Finds all occurrences of the given text in this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Matcher</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>matcher(String | Pattern)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns a Java regular expression over the HString for the given pattern.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>matches(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns true if the HString matches the given regular expression.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>replace(CharSequence, CharSequence)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replaces all substrings of this HString that matches the given string with the given replacement.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>replaceAll(CharSequence, CharSequence)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replaces all substrings of this HString that matches the given regular expression with the given replacement.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>replaceFirst(CharSequence, CharSequence)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replaces the first substring of this HString that matches the given regular expression with the given replacement.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>context(AnnotationType, int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates an HString representing the given window size of annotations of the given type on both the left and right side without going past sentence boundaries.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>context(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates an HString representing the given window size of tokens on both the left and right side without going past sentence boundaries.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>rightContext(AnnotationType, int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates an HString representing the given window size of annotations of the given type to the right of the end of this HString without going past the sentence end.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>rightContext(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates an HString representing the given window size of tokens to the right of the end of this HString without going past the sentence end.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>leftContext(AnnotationType, int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates an HString representing the given window size of annotations of the given type to the left of the end of this HString without going past the sentence start.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>leftContext(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates an HString representing the given window size of tokens to the left of the start of this HString without going past the sentence start.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;HString&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>split(Predicate&lt;? super Annotation&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Splits this HString using the given predicate to apply against tokens.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>startsWith(CharSequence)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns true if the HString starts with the given CharSequence.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>subString(int, int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns a new HString that is a substring of this one.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char[]</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>toCharArray()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns a character array representation of this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>toLowerCase()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns a lowercased version of this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>toUpperCase()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns an uppercased version of this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>trim(Predicate&lt;? super HString&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Trims the left and right ends of the HString removing tokens matching the given predicate.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>trimLeft(Predicate&lt;? super HString&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Trims the left end of the HString removing tokens matching the given predicate.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>trimRight(Predicate&lt;? super HString&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Trims the right end of the HString removing tokens matching the given predicate.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>union(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructs a new HString that has the shortest contiguous span that combines all of the tokens in this HString and the given HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>union(HString, HString, HString&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Static method that constructs a new HString that has the shortest contiguous span that combines all of the tokens in all given HStrings.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>union(Iterable&lt;? extends HString&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Static method that constructs a new HString that has the shortest contiguous span that combines all of the tokens in all given HStrings.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;HString&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>charNGrams(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extracts character n-grams of the given order from the HString</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;HString&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>charNGrams(int,int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extracts character n-grams ranging from the given minimum to given maximum order from the HString</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>HStrings store attributes using an <strong>AttributeMap</strong> which maps <strong>AttributeType</strong> to values.
HStrings provide Map-like access to their attributes through the following methods:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>attribute(AttributeType&lt;T&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the value of the given attribute associated with the HString or null if the attribute is not present.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>attribute(AttributeType&lt;T&gt;, T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the value of the given attribute associated with the HString or the given default value if the attribute is not present.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>attributeEquals(AttributeType&lt;T&gt;, Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the attribute is present on the HString and its value is equal to given value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>attributeIsA(AttributeType&lt;T&gt;, Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the attribute is present on the HString and its value is equal to given value or is an instance of the given value if the AttributeType&#8217;s value is an instance of <strong>Tag</strong>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>hasAttribute(AttributeType&lt;T&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the HString has a value for the given AttributeType.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>removeAttribute(AttributeType&lt;T&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Removes any associated value for the given AttributeType from the HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>put(AttributeType&lt;T&gt;, T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the given AttributeType returning the old value or null if there was not one.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>putAdd(AttributeType&lt;T&gt;, Iterable&lt;E&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adds the given values to the given attribute which represents a Collection of values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>putAll(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Copies the attributes and values from the given HString</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>putAll(Map&lt;AttributeType&lt;?&gt;,?)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Copies all attributes and values from the given Map</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>putIfAbsent(AttributeType&lt;T&gt;, T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the given attribute to the given value if the HString does not already have a value for the attribute.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>computeIfAbsent(AttributeType&lt;T&gt;, Supplier&lt;T&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the given attribute to the given value if the HString does not already have a value for the attribute.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>POS</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>pos()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the <code>PART_OF_SPEECH</code> attribute for the HString or calculates the best part-of-speech if the attribute is not present.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="💡"></i>
</td>
<td class="content">
Look at the <strong>GettingStarted.java</strong> and <strong>HStringIntroduction.java</strong> in the examples project for more information on handling Attributes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The power of HStrings is fast access to the <a href="#annotations">Annotation</a> that they overlap and/or enclose.
The following methods define the basic annotation API:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>annotations()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations overlapping with this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>annotations(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations of the given type overlapping with this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>annotations(AnnotationType, Predicate&lt;? super Annotation&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations of the given type overlapping with this HString that evaluate to true using the given Predicate.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>annotationStream()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets a java Stream over all annotations overlapping this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>annotationStream(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets a java Stream over all annotations of the given type overlapping this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>asAnnotation()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Casts this HString as Annotation if it already is one otherwise creates a dummy annotation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>asAnnotation(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Casts this HString as Annotation as the given type if it is an instance of that type otherwise creates a dummy annotation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>enclosedAnnotations()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations enclosed by this HString</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>enclosedAnnotations(AnnotationTYpe)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations of the given type enclosed by this HString</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>first(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the first annotation of the given type overlapping with this HString or an empty Annotation if there is none.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>firstToken()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the first token overlapping with this HString or an empty Annotation if there is none.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>forEach(AnnotationType, Consumer&lt;? super Annotation&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convenience method for processing annotations of a given type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>hasAnnotation(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if an annotation of the given type overlaps with this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>interleaved(AnnotationType&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the annotations of the given types that overlap this string in a maximum match fashion. Each token in the string is examined and the annotation type with the longest span on that token is chosen. If more than one type has the span length, the first one found will be chosen, i.e. the order in which the types are passed in to the method can effect the outcome.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>isInstance(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if this HString is an instance of the given AnnotationType.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>last(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the last annotation of the given type overlapping with this HString or an empty Annotation if there is none.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>lastToken()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the last token overlapping with this HString or an empty Annotation if there is none.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>next(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the annotation of a given type that is next in order (of span) to this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>sentence()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the first sentence overlapping with this HString or an empty Annotation if there is none.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>sentences()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all sentences overlapping with this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>sentenceStream()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all sentences overlapping with this HString as a Java stream.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>startingHere(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations of the given type with the starting character offset as this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>tokenAt(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the token at the given index relative to the HString (i.e. 0 for the first token, 1 for the second token, etc).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>tokens()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all tokens overlapping with this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>tokenStream()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all tokens overlapping with this HString as a Java stream.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="💡"></i>
</td>
<td class="content">
Look at the <strong>GettingStarted.java</strong> and <strong>CustomAnnotator.java</strong> in the examples project for more information on handling Annotations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, HStrings provide access to the incoming and outgoing <a href="#relations">Relation</a> directly annotated on them and in their overlapping annotations.</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>add(Relation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adds an outgoing relation to the object</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>addAll(Iterable&lt;Relation&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adds multiple outgoing relations to the object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RelationGraph</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>annotationGraph(Tuple, AnnotationType&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructs a relation graph with the given relation types as the edges and the given annotation types as the vertices.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>children()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all child annotations, i.e. those annotations that have a dependency relation pointing this HString.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>children(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all child annotations, i.e. those annotations that have a dependency relation pointing this HString, with the given dependency relation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Tuple2&lt;String,Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>dependency()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Get dependency relation for this annotation made up the relation and its parent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RelationGraph</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>dependencyGraph()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a RelationGraph with dependency edges and token vertices.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RelationGraph</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>dependencyGraph(AnnotationType&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a RelationGraph with dependency edges and vertices made up of the given types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>dependencyIsA(String&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the dependency relation equals any of the given relations</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>hasIncomingRelation(RelationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if an incoming relation of a given type is associated with the HString (includes sub-annotations)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>hasIncomingRelation(RelationType, String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if an incoming relation of a given type with the given value is associated with the HString (includes sub-annotations)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>hasOutgoingRelation(RelationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if an outgoing relation of a given type is associated with the HString (includes sub-annotations)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>hasOutgoingRelation(RelationType, String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if an outgoing relation of a given type with the given value is associated with the HString (includes sub-annotations)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>head()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the token that is highest in the dependency tree for this HString</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>incoming(RelationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations that have relation with this HString as the target where this HString includes all sub-annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>incoming(RelationType, boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations that have relation with this HString as the target, including sub-annotations if the given boolean value is <strong>true</strong>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>incoming(RelationType, String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations that have relation with this HString as the target where this HString includes all  sub-annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>incoming(RelationType, String, boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations that have relation with this HString as the target where this HString, including sub-annotations if the given boolean value is <strong>true</strong>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Relation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>incomingRelations()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all incoming relations to this HString including sub-annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Relation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>incomingRelations(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all incoming relations to this HString including sub-annotations if the given boolean is <strong>true</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Relation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>incoming(RelationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all relations of the given type targeting this HString or one of its sub-annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Relation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>incoming(RelationType, boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all relations of the given type targeting this HString or one of its sub-annotations if the given boolean is <strong>true</strong>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>outgoing(RelationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations that have relation with this HString as the source where this HString includes all sub-annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>outgoing(RelationType, boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations that have relation with this HString as the source, including sub-annotations if the given boolean value is <strong>true</strong>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>outgoing(RelationType, String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations that have relation with this HString as the source where this HString includes all sub-annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Annotation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>outgoing(RelationType, String, boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all annotations that have relation with this HString as the source where this HString, including sub-annotations if the given boolean value is <strong>true</strong>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Relation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>outgoingRelations()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all outgoing relations to this HString including sub-annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Relation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>outgoingRelations(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all outgoing relations to this HString including sub-annotations if the given boolean is <strong>true</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Relation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>outgoing(RelationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all relations of the given type originating from this HString or one of its sub-annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Relation&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>outgoing(RelationType, boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets all relations of the given type originating from this HString or one of its sub-annotations if the given boolean is <strong>true</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>parent()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the dependency parent of this HString</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>removeRelation(Relation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Removes the given Relation.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="💡"></i>
</td>
<td class="content">
Look at the <strong>DependencyParseExample.java</strong> and <strong>SparkSVOExample.java</strong> in the examples project for more information on handling Relations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="annotations"><a class="link" href="#annotations">3.3. Annotation</a></h3>
<div class="paragraph">
<p>An annotation is an <a href="#hstring">HString</a> that associates an <a href="#annotation_type">AnnotationType</a>, e.g. token, sentence, named entity, to a specific span of characters in a document, which may include the entire document.
Annotations typically have attributes, e.g. part-of-speech, entity type, etc, and relations, e.g. dependency and co-reference, associated with them.
Annotations are assigned a <em>long</em> id when attached to a document, which uniquely identifies it within that document.
Annotations provide the following extra methods to the standard set of HString methods:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>getId()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the unique long id assigned to the Annotation when attached to a document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationType</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>getType()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the AnnotationType associated with this Annotation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Tag</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>getTag()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the Tag value associated with this annotation (see the <a href="#tags">Tags</a> section more information on Tags)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>hasTag()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the annotation has a value associated with its Tag attribute.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>tagEquals(Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the annotation has a tag value and the tag value is equal to  the given tag (Note that the method parameter will be decoded into a Tag)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>tagIsA(Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the annotation has a tag value and the tag value is an instance of to  the given tag (Note that the method parameter will be decoded into a Tag)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>attach()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attaches, i.e. adds, the annotation to its document.</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_creating_annotations"><a class="link" href="#_creating_annotations">3.3.1. Creating Annotations</a></h4>
<div class="paragraph">
<p>The primary way of creating an annotation is through an <em>AnnotationBuilder</em> on a <a href="#document">Document</a>.
An AnnotationBuilder provides the following methods for constructing an annotation:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationBuilder</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>attribute(AttributeType, Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of the given AttributeType on the new Annotation to the given value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationBuilder</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>attributes(Map&lt;AttributeType&lt;?&gt;,?&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Copies the AttributeTypes and values from the map into the new annotation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationBuilder</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>attributes(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Copies the AttributeTypes and values from the given HString into the new annotation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationBuilder</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>bounds(Span)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the bounds (start and end character offset) of the annotation to that of the given span.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationBuilder</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>start(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the start character offset of the annotation in the document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationBuilder</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>end(int)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the end character offset of the annotation in the document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationBuilder</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>from(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Conveinince method for calling <code>bounds(HString)</code>, <code>attributes(HString)</code>, and <code>relations(HString)</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationBuilder</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>relation(Relation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adds the given relation to the new Annotation as an outgoing relation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnnotationBuilder</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>relation(Iterable&lt;Relation&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adds all of the given relation to the new Annotation as an outgoing relations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>createAttached()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates and attaches the annotation to the document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>createDetached()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates the annotation but does not attach it to the document.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>As an example of creating Annotations, let&#8217;s assume we want to add ENTITY annotations to all occurrences of GengoAI in a document.
We can do this as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Document</span> doc = ...;

<span class="type">int</span> startAt = <span class="integer">0</span>;
HString mention;
<span class="keyword">while</span>( !(mention=doc.find(<span class="string"><span class="delimiter">&quot;</span><span class="content">GengoAI</span><span class="delimiter">&quot;</span></span>, startAt)).isEmpty() ){ <i class="conum" data-value="1"></i><b>(1)</b>
     doc.annotationBuilder(<span class="predefined-type">Types</span>.ENTITY) <i class="conum" data-value="2"></i><b>(2)</b>
        .bounds(mention)
        .attribute(<span class="predefined-type">Types</span>.ENTITY_TYPE, Entities.ORGANIZATION) <i class="conum" data-value="3"></i><b>(3)</b>
        .createAttached();
     startAt = mention.end(); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Continue while we have found a mention of "GengoAI" from the <em>startAt</em> position.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We will create an AnnotationBuilder with type ENTITY and assume the bounds of the mention match.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Set the ENTITY_TYPE attribute to the value ORGANIZATION.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Increment the next start index.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The difference between an attached and detached annotation is attached annotations (1) have an assigned id, (2) are accessible through the HString annotation methods, and (3) can be the target of relations.
Detached annotations are meant to be used as intermediatory or temporary annotations often constructed by an Annotator which uses a global document context to filter or combine annotations.</p>
</div>
</div>
<div class="sect3">
<h4 id="tags"><a class="link" href="#tags">3.3.2. Tags</a></h4>
<div class="paragraph">
<p>Every AnnotationType has an associated <a href="#tags">Tag</a> attribute type.
The Tag defines the central attribute of the annotation type.
For example, Hermes defines the PART_OF_SPEECH tag to be the central attribute of tokens and the ENTITY_TYPE tag as the central attribute of entities.
An annotation&#8217;s Tag attribute can be accessed through the <code>getTag()</code> method on the annotation or through the <code>attribute(AttributeType&lt;?&gt;)</code> method, note that an annotation&#8217;s tag is assigned to the specific AttributeType (e.g. PART_OF_SPEECH) but is also accessible through the TAG AttributeType.</p>
</div>
<div class="paragraph">
<p>Tags have the following properties:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 9.0909%;">
<col style="width: 90.9091%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the tag, e.g. PART_OF_SPEECH. For tags which are hierarchical the name is the full path without the root, e.g. ORGANIZATION$POLITICAL_ORGANIZATION$GOVERNMENT.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">label</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The label of the tag, which for hierarchal tags is the leaf level name, i.e. for ORGANIZATION$POLITICAL_ORGANIZATION$GOVERNMENT the label would be GOVERNMENT.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">parent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The parent tag of this one, where <em>null</em> means the tag is a root. Note all non-hierarchical tags have a null parent.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Names and labels must be unique within in a tag set, i.e. an entity type tag set can only contain one tag with the label <em>QUANTITY</em> meaning you are not allowed to define a <em>MEASUREMENT$QUANTITY</em> and <em>NUMBER$QUANTITY</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_core_annotations"><a class="link" href="#_core_annotations">3.3.3. Core Annotations</a></h4>
<div class="paragraph">
<p>Hermes provides a number of annotation types out-of-the-box and the ability to create custom annotation types easily from lexicons and existing training data.
Here, we discuss the core set of annotation types that Hermes provides.</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 85.7143%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TOKEN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tokens represent, typically, the lowest level of annotation on a document. Hermes equates a token to mean a word (this is not always the case in other libraries depending on the language). A majority of the attribute and relation annotators are designed to enhance (i.e. add attributes and relations) to tokens. For example, the part-of-speech annotator adds part-of-speech information to tokens and the dependency annotator provides dependency relations between tokens.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SENTENCE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sentences represent a set of words typically comprised of a subject and a predict. Sentences have an associated INDEX attribute that denote the index of the sentence in the document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PHRASE_CHUNK</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Phrase chunks represent the output of a shallow parse (sometimes also referred to as a light parse). A chunk is associated with a part-of-speech, e.g noun, verb, adjective, or preposition.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENTITY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The entity annotation type serves as a parent for various named entity recognizers. Entities are associated with an EntityType, which is a hierarchy defining the types of entities (e.g. a entity type of MONEY has the parent NUMBER).</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="💡"></i>
</td>
<td class="content">
Take a look at <strong>CustomAnnotator.java</strong>, <strong>LexiconExample.java</strong>, and <strong>GettingStarted.java</strong> in the Hermes examples project to see examples of using annotations and creating custom annotation types.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="relations"><a class="link" href="#relations">3.4. Relation</a></h3>
<div class="paragraph">
<p>Relations provide a mechanism to link two Annotations.
Relations are directional, i.e. they have a source and a target, and form a directed graph between annotations on the document.
Relations can represent any type of link, but often represent syntactic (e.g. dependency relations), semantic (e.g. semantic roles), or pragmatic (e.g. dialog acts) information.
Relations, like attributes, are stored as key value pairs with the key being the <a href="#relation_type">RelationType</a> and the value being a String representing the label.
Relations are associated with individual annotations (i.e. tokens for dependency relations, entities for co-reference).
Methods on <a href="#hstring">HString</a> allow for checking for and retrieving relations for <em>sub-annotations</em> (i.e. ones which it overlaps with), which allows for analysis at different levels, such as dependency relations between phrase chunks.</p>
</div>
<div class="sect3">
<h4 id="_dependency_relations"><a class="link" href="#_dependency_relations">3.4.1. Dependency Relations</a></h4>
<div class="paragraph">
<p>Dependency relations are the most common relation and connect and label pairs of words where one word represents the head and the other the dependent.
The assigned relations are syntactic, e.g. <em>nn</em> for noun-noun, <em>nsubj</em> for noun subject of a predicate, and <em>advmod</em> for adverbial modifier, and the relation points from the dependent (source) to the head (target).
Because of their wide use, Hermes provides convenience methods for working dependency relations.
Namely, the <code>parent</code> and <code>children</code> methods on <a href="#hstring">HString</a> provide access to the dependents and heads of a specific token and the <code>dependencyRelation</code> method provides access to the head (parent) of the token and the relation between it and its head.</p>
</div>
</div>
<div class="sect3">
<h4 id="_relation_graphs"><a class="link" href="#_relation_graphs">3.4.2. Relation Graphs</a></h4>
<div class="paragraph">
<p>In some cases it is easier to work with annotations and relations as a real graph.
For these cases, Hermes provides the <code>dependencyGraph</code> and <code>annotationGraph</code> methods on <a href="#hstring">HString</a>.
These methods construct a Mango Graph!<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> with which you can render to an image, perform various clustering algorithms, find paths between annotations, and score the annotations using methods such as PageRank.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="document"><a class="link" href="#document">3.5. Document</a></h3>
<div class="paragraph">
<p>A Document is represented as a text (HString) and its associated attributes (metadata), annotations, and relations between annotations.
Every document has an id associated with it, which should be unique within a corpus.
Documents provide the following additional methods on top of the ones inherited from HString:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>annotate(AnnotatableType&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Annotates the document for the given types ensuring that all required AnnotatableTypes are also annotated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>annotation(long)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Retrieve an Annotation by its unique id.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>attach(Annotation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attaches the given annotation to the document assigning it a unique annotation id.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Set&lt;AnnotatableType&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>completed()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the set of AnnotatableType that have been annotated or marked as being annotated on this document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>getAnnotationProvider(AnnotatableType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the name and version of the annotator that provided the given AnnotatableType.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>isCompleted(AnnotatableType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the given AnnotatableType  has been annotated or marked as being annotated on this document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>numberOfAnnotations()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the number of Annotation on the document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>remove(Annotation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Removes the given annotation returning <strong>true</strong> if it was successfully removed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>removeAnnotationType(AnnotationType)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Removes all annotations of the given type and marks that type as incomplete.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>setCompleted(AnnotatableType,String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the given AnnotatableType as being complete with the given provider.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Document</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>fromJson(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Static method to deserialize a Json string into a Document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>toJson()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Serializes the document into Json format.</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_creating_documents"><a class="link" href="#_creating_documents">3.5.1. Creating Documents</a></h4>
<div class="paragraph">
<p>Documents are created using a DocumentFactory, which defines the preprocessing (e.g whitespace and unicode normalization) steps (TextNormalizers) to be performed on raw text before creating a document and the default language with which the documents are written.
The default DocumentFactory has its default language and TextNormalizers specified via configuration as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>hermes {

  ## Set default language to English
  DefaultLanguage = ENGLISH

  #By default the document factory will normalize unicode and white space
  preprocessing {
    normalizers = hermes.preprocessing.UnicodeNormalizer
    normalizers += "hermes.preprocessing.WhitespaceNormalizer"
    normalizers += "hermes.preprocessing.HtmlEntityNormalizer"
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default set of TextNormalizers includes:</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="1">
<li>
<p>A UnicodeNormalizer which normalizes Strings using NFKC normalization (Compatibility decomposition, followed by canonical composition).</p>
</li>
<li>
<p>A WhitespaceNormalizer which collapses multiple whitespace and converts newlines to linux (\n) format.</p>
</li>
<li>
<p>A HtmlEntityNormalizer which converts named and hex html entities to characters.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following snippet illustrates creating a document using the default DocumentFactory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Document</span> document = DocumentFactory.getInstance().create(<span class="string"><span class="delimiter">&quot;</span><span class="content">...My Text Goes Here...</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience a document can also be created using static methods on the document class, which will use the default DocumentFactory as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Document</span> d1 = <span class="predefined-type">Document</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">...My Text Goes Here...</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
<span class="predefined-type">Document</span> d2 = <span class="predefined-type">Document</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-unique-id</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">...My Text Goes Here...</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="2"></i><b>(2)</b>
<span class="predefined-type">Document</span> d3 = <span class="predefined-type">Document</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">Este es un documento escrito en español.</span><span class="delimiter">&quot;</span></span>, Language.SPANISH); <i class="conum" data-value="3"></i><b>(3)</b>
<span class="predefined-type">Document</span> d4 = <span class="predefined-type">Document</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">...My Text Goes Here...</span><span class="delimiter">&quot;</span></span>, <i class="conum" data-value="4"></i><b>(4)</b>
                              Maps.of(<span class="error">$</span>(<span class="predefined-type">Types</span>.SOURCE, <span class="string"><span class="delimiter">&quot;</span><span class="content">The document source</span><span class="delimiter">&quot;</span></span>),
                                      <span class="error">$</span>(<span class="predefined-type">Types</span>.AUTHOR, <span class="string"><span class="delimiter">&quot;</span><span class="content">A really important person</span><span class="delimiter">&quot;</span></span>)));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creation of a document specifying only the content.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creation of a document specifying its unique id and its content.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creation of a document specifying the language the document is written in.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Creation of a document specifying a set of attributes associated with it.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>DocumentFactories provide additional methods for constructing documents from pre-tokenized text (<code>fromTokens</code>) and to force the factory to ignore the string preprocessing (<code>createRaw</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_working_with_documents"><a class="link" href="#_working_with_documents">3.5.2. Working with Documents</a></h4>
<div class="paragraph">
<p><a href="#annotations">Annotations</a> are spans of text on the document which have their own associated set of attributes and relations.
Annotations are added to a document using a AnnotationPipeline.
The pipeline defines the type of annotations, attributes, and relations that will be added to the document.
However, Document and Corpora provide a convenience method <code>annotate(AnnotatableType&#8230;&#8203;)</code> that takes care of constructing the pipeline and calling its annotation method.
The following snippet illustrates annotating a document for TOKEN, SENTENCE, and PART_OF_SPEECH:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Document</span> d1 = <span class="predefined-type">Document</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">...My Text Goes Here...</span><span class="delimiter">&quot;</span></span>);
d1.annotate(<span class="predefined-type">Types</span>.TOKEN, TYPES.SENTENCE, TYPES.PART_OF_SPEECH) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <strong>Types</strong> class contains a number of pre-defined AnnotatableType</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ad-hoc annotations are easily added using one of the <code>createAnnotation</code> methods on the document.
The first step is to define your AnnotationType:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AnnotationType animalMention = <span class="predefined-type">Types</span>.type(<span class="string"><span class="delimiter">&quot;</span><span class="content">ANIMAL_MENTION</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s identify animal mentions using a simple regular expression.
Since Document extends HString we have time saving methods for dealing with the textual content.
Namely, we can easily get a Java regex Matcher for the content of the document by:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Matcher</span> matcher = document.matcher(<span class="string"><span class="delimiter">&quot;</span><span class="char">\\</span><span class="content">b(fox|dog)</span><span class="char">\\</span><span class="content">b</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the matcher, we can iterate over the matches and create new annotations as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">while</span> (matcher.find()) {
   document.createAnnotation(animalMention,
                             matcher.start(),
                             matcher.end());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>More complicated annotation types would also provide attributes, for example entity type, word sense, etc.
Once annotations have been added to a document they can be retrieved using the <code>annotations(AnnotationType)</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">document.get(animalMention)
        .forEach(a -&gt; <span class="predefined-type">System</span>.out.println(a + <span class="string"><span class="delimiter">&quot;</span><span class="content">[</span><span class="delimiter">&quot;</span></span> + a.start() + <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> + a.end() + <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, convenience methods exist for retrieving tokens, <code>tokens()</code>, and sentences, <code>sentences()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">document.sentences().forEach(<span class="predefined-type">System</span>.out::println);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A document stores its associated annotations using an AnnotationSet.
The default implementation uses an interval tree backed by a red-black tree, which provides O(n) storage and average O(log n) for search, insert, and delete operations.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="corpus"><a class="link" href="#corpus">3.6. Document Collections and Corpora</a></h3>
<div class="paragraph">
<p>A collection of documents in Hermes is represented using either a <em>DocumentCollection</em> or <em>Corpus</em>.
The difference between the two is that a <em>Corpus</em> represents a <strong>persistent</strong> collection of documents whereas a <em>DocumentCollection</em> is a <strong>temporary</strong> collection used for ad-hoc analytics or to import documents into a corpus.
The figure below, shows a typical flow of data in which: (1) A document is collection is created by reading files in a given format (e.g. plain text, html, pdf, etc.); (2) The files are imported into a Corpus for processing; (3) Operations, e.g. annotation, are performed over the corpus which allows these operations to be persisted; and (4) Optionaly, the documents in the corpus in are exported to a set of files in a given format (e.g. CoNLL).</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/document-flow.png" alt="document flow" width="800px" height="196">
</div>
<div class="title">Figure 3. Typical flow of documents from Raw input to Corpus creation.</div>
</div>
<div class="paragraph">
<p>Hermes provides the ability to easily create, read, write, and analyze document collections and corpora locally and distributed.
Both makes it easy to annotate documents with a desired set of annotations, attributes, and relations, query the documents using keywords, and perform analyses such as term extraction, keyword extraction, and significant n-gram extraction.</p>
</div>
<div class="sect3">
<h4 id="_document_formats"><a class="link" href="#_document_formats">3.6.1. Document Formats</a></h4>
<div class="paragraph">
<p>Hermes provides a straightforward way of reading and writing documents in a number of formats, including plain text, csv, and json.
In addition, many formats can be used in a "one-per-line" corpus where each line represents a single document in the given format.
For example, a json one-per-line corpus has a single json object representing a document on each line of the file.
Each document format has an associated set of <em>DocFormatParameters</em> that define the various options for reading and writing in the format.
By default the following parameters can be set:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>defaultLanguage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The default language for new documents. (default calls <code>Hermes.defaultLanguage()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>normalizers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The class names of the text normalizes to use when constructing documents. (default calls <code>TextNormalization.configuredInstance().getPreprocessors()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>distributed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a distributed document collection when the value is set to <strong>true</strong> (default <code>false</code>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>saveMode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to <em>overwrite</em>, <em>ignore</em>, or <em>throw an error</em> when writing a corpus to an existing file/directory (default <code>ERROR</code>).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table lists the included document formats with their added format parameters and read/write capabilities:</p>
</div>
<table id="formats" class="tableblock frame-all grid-all stripes-odd stretch">
<caption class="title">Table 1. Document formats included with Hermes</caption>
<colgroup>
<col style="width: 22.2222%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 44.4445%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Format Name</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Read</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Write</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Support OPL</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TEXT</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Plain text documents.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="5"><div class="content"><div class="ulist">
<ul>
<li>
<p>Standard Document Format  Parameters Only</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PTB</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Penn Treebank bracketed (.mrg) files</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="5"><div class="content"><div class="ulist">
<ul>
<li>
<p>Standard Document Format  Parameters Only</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HJSON</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hermes Json format.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="5"><div class="content"><div class="ulist">
<ul>
<li>
<p>Standard Document Format Parameters Only</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONLL</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONLL format.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="5"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>docPerSentence=[true|false]</code>: One document per sentence when <strong>true</strong> (default: <strong>true</strong>).</p>
</li>
<li>
<p><code>fields=&lt;list of fields&gt;</code>: list of string denoting the field names (default: ["WORD", "POS", "CHUNK")]).</p>
</li>
<li>
<p><code>fs=&lt;String&gt;</code>: Field separator (default: "\\s+")</p>
</li>
<li>
<p><code>overrideSentences=[true|false]</code>: Override the CONLL sentence boundaries with Hermes boundaries when <strong>true</strong> (default: <strong>false</strong>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following fields are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>INDEX - The index of the word in the sentence.</p>
</li>
<li>
<p>WORD  - The word.</p>
</li>
<li>
<p>LEMMA - The lemmatized form of the word.</p>
</li>
<li>
<p>UPOS  - The universal part-of-speech tag of the word.</p>
</li>
<li>
<p>POS   - The part-of-speech tag of the word.</p>
</li>
<li>
<p>CHUNK - IOB annotated Phrase Chunks.</p>
</li>
<li>
<p>ENTITY - IOB annotated Named Entities.</p>
</li>
<li>
<p>HEAD   - The index of this word&#8217;s syntactic head in the sentence.</p>
</li>
<li>
<p>DEP_REL - The dependency relation of this word to its head.</p>
</li>
<li>
<p>IGNORE  - Ignores the field.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CSV</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Delimited separated files (e.g. CSV and TSV) with each row representing a document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="5"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>columns=&lt;list of column names&gt;</code>: The list of column names when file does not have a header (default: empty).</p>
</li>
<li>
<p><code>content=&lt;String&gt;</code>: Name of the content column (default: "content").</p>
</li>
<li>
<p><code>id=&lt;String&gt;</code>: Name of the document id column (default: "id").</p>
</li>
<li>
<p><code>language=&lt;String&gt;</code>: Name of the language column (default: "language").</p>
</li>
<li>
<p><code>comment=&lt;Character&gt;</code>: The character used for comments in the file (default: '#').</p>
</li>
<li>
<p><code>delimiter=&lt;Character&gt;</code>: The character used for delimiting columns in the file (default: ',').</p>
</li>
<li>
<p><code>hasHeader=[true|false]</code>: The file has a header naming the columns when <strong>true</strong> (default: false).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that columns name will be autogenerated as C0, C1, &#8230;&#8203;, CN when no column names are given and there is no header in the file. Additional columns in the file not assigned to "id", "language", or "content" will be treated as document level attributes.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TWITTER_SEARCH</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Twitter API Search result</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="5"><div class="content"><div class="ulist">
<ul>
<li>
<p>Standard Document Format  Parameters Only</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>POS</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Format with words separated by whitespace and POS tags appended with an underscore, e.g. The_DT brown_JJ.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="5"><div class="content"><div class="ulist">
<ul>
<li>
<p>Standard Document Format  Parameters Only</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TAGGED</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Format with words separated by whitespace and sequences labeled in SGML like tags, e.g. &lt;TAG&gt;My text&lt;/TAG&gt;.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="5"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>annotationType=&lt;String&gt;</code>: The annotation type that sequences are an instance of (default: ENTITY).</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <strong>Format Name</strong> is used to identify the document format to read and to use the format with one-per-line, you can append "_opl" to the format name.</p>
</div>
</div>
<div class="sect3">
<h4 id="_document_collection_creation"><a class="link" href="#_document_collection_creation">3.6.2. Document Collection Creation</a></h4>
<div class="paragraph">
<p>The <em>DocumentCollection</em> class provides the following methods to create a document collection from a series of documents:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 57.1429%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DocumentCollection</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>create(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">creates a document collection from documents stored in the format and at the location specified by the given specification.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DocumentCollection</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>create(Specification)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">creates a document collection from documents stored in the format and at the location specified by the given specification.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DocumentCollection</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>create(Document&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a document collection in memory containing the given documents.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DocumentCollection</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>create(List&lt;Document&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a document collection in memory containing the given documents.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DocumentCollection</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>create(MStream&lt;Document&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a document collection from the given Mango stream where the corpus will be distributed if the given Mango stream is also distributed and a streaming corpus otherwise.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DocumentCollection</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>create(Stream&lt;Document&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a stream-based corpus containing the given documents.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following is an example of creating a document collection from Twitter data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DocumentCollection twitter = DocumentCollection.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">twitter_search::/data/twitter_search_results/</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more complex example is creation from CSV files:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DocumentCollection csv = DocumentCollection.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">csv::/data/my_csv.csv;columns=id,content,language,author,source</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_working_with_document_collections_and_corpora"><a class="link" href="#_working_with_document_collections_and_corpora">3.6.3. Working with Document Collections and Corpora</a></h4>
<div class="paragraph">
<p>The Hermes <em>Corpus</em> and <em>DocumentCollection</em> class provides a variety of different methods for accessing, analyzing, and manipulating its documents.</p>
</div>
<div class="sect4">
<h5 id="_accessing_documents"><a class="link" href="#_accessing_documents">Accessing Documents</a></h5>
<div class="paragraph">
<p>Document collections and corpora allow for the following access to their collection of documents:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterator&lt;Document&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>iterator()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets an iterator over the documents in the corpus.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MStream&lt;Document&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>stream()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns a Mango stream over the documents in the corpus.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MStream&lt;Document&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>parallelStream()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns a parallel Mango stream over the documents in the corpus.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In addition to the methods above, corpora allow for access to individual documents using <code>get(String)</code> method where the string parameter is the document id.</p>
</div>
</div>
<div class="sect4">
<h5 id="_manipulating_the_corpus_and_its_documents"><a class="link" href="#_manipulating_the_corpus_and_its_documents">Manipulating the Corpus and its Documents</a></h5>
<div class="paragraph">
<p>The main method for manipulation of a collection is through the <code>update(SerializableConsumer&lt;Document&gt;)</code> method, which processes each document using the given consumer.
For document collections this method acts as a map whereas for corpora the update persists to the underlying storage.</p>
</div>
<div class="paragraph">
<p>Corpora also allow for individual documents to be udpated via the <code>update(Document)</code> method.
Additionally, documents can be added and removed from corpora using the following set of methods:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>add(Document)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adds a document to the corpus.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>addAll(Iterable&lt;Document&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adds the given documents to the corpus.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>importDocuments(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Imports documents from the given document collection specification.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>remove(Document)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the given Document was successfully removed from the corpus.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>remove(String)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the document with the given document id was successfully removed from the corpus.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_querying"><a class="link" href="#_querying">Querying</a></h5>
<div class="paragraph">
<p>Hermes provides a simple boolean query language to query documents.
The query syntax is as follows:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Operator</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires the queries, phrases, or words on the left and right of the operator to both be present in the document. (AND is case insensitive)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires for one of the queries, phrases, or words on the left and right of the operator to be present in the document. (OR is case insensitive)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires the query, phrase, or word on its right hand side to <strong>not</strong> be in the document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$ATTRIBUTE='VALUE'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires the value of the document attribute describe after the $ to equal the value in the parenthesis.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'PHRASE'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Searches for the phrase defined between the single quotation marks. (note if the phrase includes a single quote it can be escaped using the backslash character.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WORD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Searches for the word (note the word cannot start or end with parenthesis and cannot have whitespace)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Multiword phrases are expressed using quotes, e.g. <code>'United States'</code> would match the entire phrase whereas <code>United AND States</code> only requires the two words to present in the document in any order.
The default operator when one is not specified is <code>OR</code>, i.e. <code>United States</code> would be expanded to <code>United OR States</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Corpus corpus = ...;
SearchResults results = corpus.query(<span class="string"><span class="delimiter">&quot;</span><span class="content">'United States' AND 'holiday'</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Query: </span><span class="delimiter">&quot;</span></span> + results.getQuery());
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Total Hits: </span><span class="delimiter">&quot;</span></span> + results.size());
<span class="keyword">for</span>( <span class="predefined-type">Document</span> document : results ){
    <span class="predefined-type">System</span>.out.println(document.getTitle());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown in the code snippet above, querying a corpus results in a <em>SearchResults</em> which retains the query that generated results and a document collection view of the results.</p>
</div>
</div>
<div class="sect4">
<h5 id="fa"><a class="link" href="#fa">Frequency Analysis</a></h5>
<div class="paragraph">
<p>A common step when analyzing a corpus is to calculate the term and document frequencies of the words in its documents.
In Hermes, the frequency of any type of annotation can be calculated across a corpus using the <code>termCount(Extractor)</code> method.
The analysis is defined using an <em>Extractor</em> object, which provides a fluent interface for defining annotation type, conversion to string form, filters, and how to calculate the term values (see <a href="#extraction">Text Mining</a> for more information on Extractors).
An example is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Corpus corpus = ...;
Extractor spec = TermExtractor.builder() <i class="conum" data-value="1"></i><b>(1)</b>
                              .toLemma()
                              .ignoreStopwords()
                              .valueCalculator(ValueCalculator.L1_NORM);
Counter&lt;<span class="predefined-type">String</span>&gt; tf = corpus.termCount(spec); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Shows creation of the <em>TermExtractor</em> which defines the way we will extract terms.
Here we specify that we want lemmas, will ignore stopwords, and want the returning counter to have its values L1 normalized.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Shows the calculating of term frequencies over the entier corpus.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the TermExtractor will specify TOKEN annotations which will be converted to a string form using the toString method, all tokens will be kept, and the raw frequency will be calculated.</p>
</div>
<div class="paragraph">
<p>In a similar manner, document frequencies can be extracted using the <code>documentCount(Extractor)</code> method.
An example is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Corpus corpus =...;
Extractor spec = TermExtractor.builder()
                              .toLemma()
                              .ignoreStopwords();
Counter&lt;<span class="predefined-type">String</span>&gt; tf = corpus.documentCount(spec);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both the <em>termCount</em> and <em>documentCount</em> methods take an <em>Extractor</em>, which can include any type of extraction technique (discussed in <a href="#extraction">Text Mining</a>).</p>
</div>
</div>
<div class="sect4">
<h5 id="_extracting_n_grams"><a class="link" href="#_extracting_n_grams">Extracting N-Grams</a></h5>
<div class="paragraph">
<p>While n-grams can be extracted using the <code>termCount</code> and <code>documentCount</code> feature, Hermes provides the <code>nGramCount(NGramExtractor)</code> method for calculating document-based counts of n-grams where the n-gram is represented as <em>Tuple</em> of string.
An example of gathering bigram counts from a corpus is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Corpus corpus = ...;
NGramExtractor extractor = NGramExtractor.bigrams() <i class="conum" data-value="1"></i><b>(1)</b>
                                         .toLemma()
                                         .ignoreStopWords()
                                         .valueCalculator(ValueCalculator.L1_NORM);
Counter&lt;Tuple&gt; tf = corpus.nGramCount(extractor); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Shows creation of the n-gram extractor which defines the way we will extract n-grams.
Here we specify that we want to extract unigrams, bigrams, and trigrams and that will convert to lemma form, ignore stopwords, and want the returning counter to have its values L1 normalized.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Shows the calculating of n-gram frequencies over the entier corpus.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the NGramExtractor will specify TOKEN annotations which will be converted to a string form using the toString method, all tokens will be kept, and the raw frequency will be calculated.</p>
</div>
<div class="paragraph">
<p>In addition, Hermes makes it easy to mine "significant bigrams" from a corpus using the <code>significantBigrams(NGramExtractor, int, double)</code> and  <code>significantBigrams(NGramExtractor, int, double, ContingencyTableCalculator)</code> methods.
Both methods take an <code>NGramExtractor</code> to define how the terms should be extracted (note that the min and max order is ignored), a (int) minimum count required to consider a bigram, and a (double) minimum score for a bigram to be considered significant.
Additionally, a <em>ContingencyTableCalculator</em> can be given which is used to calculate the score of a bigram (by default <code>Association.Mikolov</code> is used which is the calculation used within word2vec to determine phrases).
Both methods return a <em>Counter&lt;Tuple&gt;</em> containing the bigrams and their score.
The following example illustrates finding significant bigrams using Normalized Pointwise Mutual Information (NPMI):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Corpus corpus = ...;
NGramExtractor extractor = NGramExtractor.bigrams()
                                         .toLemma()
                                         .ignoreStopWords()
                                         .valueCalculator(ValueCalculator.L1_NORM);
Counter&lt;Tuple&gt; bigrams = corpus.significantBigrams(extractor, <span class="integer">5</span>, <span class="integer">0</span>, Association.NPMI); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Extract significant bigrams which have a minimum count of 5 and a minimum NPMI of 0.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_sampling"><a class="link" href="#_sampling">Sampling</a></h5>
<div class="paragraph">
<p>Often times we only want to use a small portion of a corpus to test for analysis in order to test it out.
The corpus class provides a means for performing <a href="https://en.wikipedia.org/wiki/Reservoir_sampling:">reservoir sampling</a> on the corpus using the following two methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">sample(<span class="type">int</span> size)
sample(<span class="type">int</span> size, <span class="predefined-type">Random</span> random)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both return a new corpus and take the sample size as the first parameter.
The second method takes an additional parameter of type <em>Random</em> which is used to determine inclusion of a document in the sample.
Note that for non-distributed corpora the sample size must be able to fit into memory.</p>
</div>
</div>
<div class="sect4">
<h5 id="_grouping"><a class="link" href="#_grouping">Grouping</a></h5>
<div class="paragraph">
<p>The Corpora class provides a <code>groupBy(SerializableFunction&lt;? super Document, K&gt;)</code> method for grouping documents by an arbitrary key.
The method returns a <em>Multimap&lt;K, Document&gt;</em> where <em>K</em> is the key type and takes a function that maps a <em>Document</em> to <em>K</em>.
The following code example shows where this may of help.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Corpus corpus = ...;
corpus.groupBy(doc -&gt; doc.getAttributeAsString(<span class="predefined-type">Types</span>.SOURCE)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Group documents by their source.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that because this method returns a Multimap, the entire corpus must be able to fit in memory.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extraction"><a class="link" href="#extraction">4. Text Mining</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The goal of Text Mining is to turn unstructured data into high-quality structured information.
Hermes provides a variety of tools to perform text mining over corpora, some of which were described in the <a href="#corpus">Document Collections and Corpora</a> section.
Fundamental to text mining in Hermes is the concept of a <em>Extractor</em> and the <em>Extraction</em> it produces.
Extractors are responsible for taking an <em>HString</em> as input and producing an <em>Extraction</em> as output via the <code>Extraction extract(@NonNull HString hString)</code> method.
The class hierarchy for Extractors is as follows (note names in Yellow represent abstract classes or interfaces):</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/extractor-hierarchy.png.png" alt="extractor hierarchy.png" width="800px" height="406">
</div>
<div class="title">Figure 4. Inheritance hierarchy for extractors.</div>
</div>
<div class="paragraph">
<p>The <em>Lexicon</em> extractor uses a lexicon to match terms in an <em>HString</em> and described in detail in <a href="#lexicons">Lexicons</a>.
The <em>KeywordExtractor</em> extracts key phrases from an HString based on a defined algorithm and described in detail in <a href="#keywords">Keyword Extraction</a>.
The <em>FeaturizingExtractor</em> combines an extractor with a <em>Featurizer</em> allowing for the output of the extractor to be directly used as features for machine learning.</p>
</div>
<div class="paragraph">
<p>The <em>LyreExpression</em> extractor is based on Hermes&#8217;s <a href="#lyre">Lyre Expression Language</a>.
The <em>MultiPhaseExtractor</em> is the base for <em>TermExtractor</em> and <em>NGramExtractor</em> which we looked at in the &lt;&lt;#fa&gt; section on corpora.
Multi-phase extractors define a series of steps to transforming an HString into an Extraction, which include the annotation types to extract, filters to apply on the extracted annotations, methodology for trimming the extracted annotations, methodology for converting the annotations into Strings, and a prefix for when the extraction is used as a machine learning feature.</p>
</div>
<div class="paragraph">
<p>Every extractor produces an <em>Extraction</em>.
Extractions can provide their results as an <em>Iterable</em> of <em>HString</em> or <em>String</em> or a <em>Counter&lt;String&gt;</em> via the following methods:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>size()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of items extracted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterable&lt;String&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>string()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the extracted items as an Iterable of String.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Counter&lt;String&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>count()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the extracted items as a Counter of String.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterator&lt;HString&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>iterator()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns an Iterator of the extracted HString (Note that if the extractor does not support HString it will generate a fragment).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that how the results are constructed are dependent on the extraction technique.
For example, some extractions only provide fragments (i.e. non-attached) <em>HString</em> due to the way extraction is performed.</p>
</div>
<div class="sect2">
<h3 id="lexicons"><a class="link" href="#lexicons">4.1. Lexicons</a></h3>
<div class="paragraph">
<p>A traditional approach to information extraction incorporates the use of lexicons, also called gazetteers, for finding specific lexical items in text.
Hermes&#8217;s <em>Lexicon</em> classes provide the ability to match lexical items using a greedy longest match first or maximum span probability strategy.
Both matching strategies allow for case-sensitive or case-insensitive matching and the use of constraints (using the Lyre expression language), such as part-of-speech, on the match.</p>
</div>
<div class="paragraph">
<p>Lexicons are managed using the <em>LexiconManager</em>, which acts as a cache associating lexicons with a name and a language.
This allows for lexicons to be defined via configuration and then to be loaded and retrieved by their name (this is particularly useful for annotators that use lexicons).</p>
</div>
<div class="paragraph">
<p>Lexicons are defined using a <em>LexiconSpecification</em> in the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>lexicon:(mem|disk):name(:(csv|json))*::RESOURCE(;ARG=VALUE)*</code></pre>
</div>
</div>
<div class="paragraph">
<p>The schema of the specification is "lexicon" and the currently supported protocols are:
* mem: An in-memory Trie-based lexicon.
* disk: A persistent on-disk based lexicon.</p>
</div>
<div class="paragraph">
<p>The name of the lexicon is used during annotation to mark the provider.
Additionally, a format (csv or json) can be specified, with json being the default if none is provided, to specify the lexicon format when creating in-memory lexicons.
Finally, a number of query parameters (ARG=VALUE) can be given from the following choices:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>caseSensitive=(true|false)</code>: Is the lexicon case-sensitive (<strong>true</strong>) or case-insensitive (<strong>false</strong>) (default <strong>false</strong>).</p>
</li>
<li>
<p><code>defaultTag=TAG</code>: The default tag value for entry when one is not defined (default null).</p>
</li>
<li>
<p><code>language=LANGUAGE</code>: The default language of entries in the lexicon (default <code>Hermes.defaultLanguage()</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>CSV lexicons allow for the additionaly following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lemma=INDEX</code>: The index in the csv row containing the lemma (default 0).</p>
</li>
<li>
<p><code>tag=INDEX</code>: The index in the csv row containing the tag (default 1).</p>
</li>
<li>
<p><code>probability=INDEX</code>: The index in the csv row containing the probability (default 2).</p>
</li>
<li>
<p><code>constraint=INDEX</code>: The index in the csv row containing the constraint (default 3).</p>
</li>
<li>
<p><code>language=LANGUAGE</code>: The default language of entries in the lexicon (default <code>Hermes.defaultLanguage()</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As an example, we can define the following lexicons in our configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>person.lexicon =  lexicon:mem:person:json::&lt;hermes.resources.dir:ENGLISH&gt;person.lexicon <i class="conum" data-value="1"></i><b>(1)</b>
huge.lexicon  =  lexicon:disk:everything:&lt;hermes.resources.dir:ENGLISH&gt;huge.lexicon <i class="conum" data-value="2"></i><b>(2)</b>
csv.lexicon   = lexicon:mem:adhoc:csv::/data/test/import.csv;probability=-1;constraint=2;caseSensitive=true;tagAttribute=ENTITY_TYPE;defaultTag=PERSON <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines an in-memory lexicon stored in json format named "person".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defines a disk-based lexicon named "everything".</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Defines an in-memory lexicon stored in csv format named "adhoc" that is case-sensitive, has a tag attribute of ENTITY_TYPE with a default tag of PERSON, does not use probabilities, and the constraint is stored in the second (0-based) column.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that we can use &lt;hermes.resources.dir:ENGLISH&gt; to specify that file is located in the ENGLISH directory of the Hermes resources, which is defined in the config option <code>hermes.resources.dir</code>.
The language name can be omitted when the lexicon is in the default resources.</p>
</div>
<div class="paragraph">
<p>We can retrieve a lexicon from the <em>LexiconManager</em> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Lexicon lexicon = LexiconManager.getLexicon(<span class="string"><span class="delimiter">&quot;</span><span class="content">person.lexicon</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
Lexicon undefined = LexiconManager.getLexicon(<span class="string"><span class="delimiter">&quot;</span><span class="content">undefined.lexicon</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Retrieve the person lexicon we defined previously in our config file.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Attempt to retrieve a lexicon that has not been defined via configuration.
In this case, it will try to find a json formatted lexicon with the named "undefined.lexicon.json" in one of the resource directories Hermes knows about.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The lexicon manager allows for lexicons to be manually registered using the register method, but please note that this registration will not carry over to each node in a distributed environment.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="💡"></i>
</td>
<td class="content">
Take a look at <strong>LexiconExample.java</strong> in the Hermes examples project to see examples of constructing and using lexicons.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_reading_and_writing_lexicons"><a class="link" href="#_reading_and_writing_lexicons">4.1.1. Reading and Writing Lexicons</a></h4>
<div class="paragraph">
<p>The <em>LexiconIO</em> class provides static methods for reading and writing in-memory lexicons.
The primary format of a Hermes lexicon is Json and is described as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">@spec</span><span class="delimiter">&quot;</span></span>: { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="key"><span class="delimiter">&quot;</span><span class="content">caseSensitive</span><span class="delimiter">&quot;</span></span>: <span class="value">false</span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">tagAttribute</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">ENTITY_TYPE</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">language</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">ENGLISH
  },
  </span><span class="delimiter">&quot;</span></span><span class="error">@</span><span class="error">e</span><span class="error">n</span><span class="error">t</span><span class="error">r</span><span class="error">i</span><span class="error">e</span><span class="error">s</span><span class="string"><span class="delimiter">&quot;</span><span class="content">: [ <i class="conum" data-value="2"></i><b>(2)</b>
    {
      </span><span class="delimiter">&quot;</span></span><span class="error">l</span><span class="error">e</span><span class="error">m</span><span class="error">m</span><span class="error">a</span><span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span><span class="error">g</span><span class="error">r</span><span class="error">a</span><span class="error">n</span><span class="error">d</span><span class="error">f</span><span class="error">a</span><span class="error">t</span><span class="error">h</span><span class="error">e</span><span class="error">r</span><span class="string"><span class="delimiter">&quot;</span><span class="content">,
      </span><span class="delimiter">&quot;</span></span><span class="error">t</span><span class="error">a</span><span class="error">g</span><span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span><span class="error">G</span><span class="error">R</span><span class="error">A</span><span class="error">N</span><span class="error">D</span><span class="error">P</span><span class="error">A</span><span class="error">R</span><span class="error">E</span><span class="error">N</span><span class="error">T</span><span class="string"><span class="delimiter">&quot;</span><span class="content">
    },
    {
      </span><span class="delimiter">&quot;</span></span><span class="error">l</span><span class="error">e</span><span class="error">m</span><span class="error">m</span><span class="error">a</span><span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span><span class="error">m</span><span class="error">a</span><span class="error">s</span><span class="error">o</span><span class="error">n</span><span class="string"><span class="delimiter">&quot;</span><span class="content">,
      </span><span class="delimiter">&quot;</span></span><span class="error">t</span><span class="error">a</span><span class="error">g</span><span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span><span class="error">O</span><span class="error">C</span><span class="error">C</span><span class="error">U</span><span class="error">P</span><span class="error">A</span><span class="error">T</span><span class="error">I</span><span class="error">O</span><span class="error">N</span><span class="string"><span class="delimiter">&quot;</span><span class="content">,
      </span><span class="delimiter">&quot;</span></span><span class="error">p</span><span class="error">r</span><span class="error">o</span><span class="error">b</span><span class="error">a</span><span class="error">b</span><span class="error">i</span><span class="error">l</span><span class="error">i</span><span class="error">t</span><span class="error">y</span><span class="string"><span class="delimiter">&quot;</span><span class="content">: 0.7,
      </span><span class="delimiter">&quot;</span></span><span class="error">c</span><span class="error">o</span><span class="error">n</span><span class="error">s</span><span class="error">t</span><span class="error">r</span><span class="error">a</span><span class="error">i</span><span class="error">n</span><span class="error">t</span><span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span><span class="error">!</span><span class="error">#</span><span class="error">N</span><span class="error">N</span><span class="error">P</span><span class="string"><span class="delimiter">&quot;</span><span class="content">
    },
    {
      </span><span class="delimiter">&quot;</span></span><span class="error">l</span><span class="error">e</span><span class="error">m</span><span class="error">m</span><span class="error">a</span><span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span><span class="error">h</span><span class="error">o</span><span class="error">u</span><span class="error">s</span><span class="error">e</span><span class="error">w</span><span class="error">i</span><span class="error">f</span><span class="error">e</span><span class="string"><span class="delimiter">&quot;</span><span class="content">,
      </span><span class="delimiter">&quot;</span></span><span class="error">t</span><span class="error">a</span><span class="error">g</span><span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span><span class="error">O</span><span class="error">C</span><span class="error">C</span><span class="error">U</span><span class="error">P</span><span class="error">A</span><span class="error">T</span><span class="error">I</span><span class="error">O</span><span class="error">N</span><span class="string"><span class="delimiter">&quot;</span><span class="content">
    }
  ]
}</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The "@spec" section defines the specification of the lexicon.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The "@entries" section is where the lexical entries are specified.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As seen in the snippet the json file starts with a specification section, "@spec", in which the valid parameters are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>caseSensitive</strong>: Is the lexicon case-sensitive (<strong>true</strong>) or case-insensitive (<strong>false</strong>) (default <strong>false</strong>).</p>
</li>
<li>
<p><strong>language</strong>: The language of the entries in the lexicon (default <code>Hermes.defaultLanguage()</code>).</p>
</li>
<li>
<p><strong>tag</strong>: The default tag value for entry when one is not defined (default null).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The "@entries" section defines the individual lexicon entries in the lexicon with the following valid parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>lemma</strong>: The lexical item to be matched (no default must be set).</p>
</li>
<li>
<p><strong>tag</strong>: The tag value associated with the lemma that the <em>tagAttribute</em> will be set to (default lexicon default tag).</p>
</li>
<li>
<p><strong>probability</strong>: The probability of the lexical item associated with its tag (default 1.0).</p>
</li>
<li>
<p><strong>constraint</strong>: The constraint (using a Lyre expression) that must be satisfied for the lexical match to take place (default null).</p>
</li>
<li>
<p><strong>tokenLength"</strong> Optional parameter the defines the number of tokens in the entry (default calculated based on the lexicon language).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, csv based lexicons can be imported using <code>LexiconIO.importCSV(Resource, Consumer&lt;CSVParameters&gt;)</code> where the Resource defines the location of the CSV file and the Consumer is used to specify the lexicon parameters.
The CSVParameters defines the columns for lemmas, tags, probabilities, and constraints as well as the standard lexicon information of case-sensitive or insensitive matching, tag attribute, and default tag.</p>
</div>
</div>
<div class="sect3">
<h4 id="_word_lists"><a class="link" href="#_word_lists">4.1.2. Word Lists</a></h4>
<div class="paragraph">
<p>Word lists provide a set like interface to set of vocabulary items.
Implementations of <em>WordList</em> may implement the <em>PrefixSearchable</em> interface allowing prefix matching.
Word lists are loaded from plain text files with "#" at the beginning of a line denoting a comment.
Whereas lexicons provide a robust way to match and label HStrings, _WordList_s provide a simple means of determining if a word/phrase is defined.
Note that convention states that if the first line of a word list is a comment stating "case-insensitive" then loading of that word list will result in all words being lower-cased.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lyre"><a class="link" href="#lyre">4.2. Lyre Expression Language</a></h3>
<div class="paragraph">
<p>Lyre (Linguistic querY and extRaction languagE) provides a means for querying, extracting, and transforming HStrings.
A <em>LyreExpression</em> represents a series of steps to perform over an input HString which can be used for querying (i.e. acting as a Java <em>Predicate</em>) and extracting and transforming (i.e. like a Java <em>Function</em>) using the following methods:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Method</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>apply(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression returning a String value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>applyAsDouble(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression returning a double value or <em>NaN</em> if the return value is not convertible into a double.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>applyAsDouble(Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression returning a double value or <em>NaN</em> if the return value is not convertible into a double.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Feature&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>applyAsFeatures(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression returning a list of <em>Feature</em> for machine learning.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>applyAsHString(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression returning it is an HString using <code>HString.toHstring(Object)</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;Object&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>applyAsList(Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression returning it is a list of Object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;T&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>applyAsList(Object, Class&lt;T&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression returning it is a list of type T.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>applyAsObject(Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>applyAsString(Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression returning it as a String value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Counter&lt;String&gt;</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>count(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the expression returning a count over the string results.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>test(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the expression evaluates to true.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>testObject(HString)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <strong>true</strong> if the expression evaluates to true.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A LyreExpression can be created by parsing a string representation using <code>Lyre.parse(String)</code> or by using the <code>LyreDSL</code> class to programmatically build up the expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">LyreDSL</span>.*;

LyreExpression l1 = Lyre.parse(<span class="string"><span class="delimiter">&quot;</span><span class="content">map(filter(@TOKEN, isContentWord), lower)</span><span class="delimiter">&quot;</span></span>);
LyreExpression l2 = map(filter(annotation(<span class="predefined-type">Types</span>.TOKEN), isContentWord), lower);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code snippet illustrated above gives an example of creating the same expression using both the String representation and the DSL methods.
The constructed expression extracts all TOKEN annotations from the HString input filtering them to keep only the content words (i.e. non-stopwords) with the resulting list of filtered tokens mapped to a lowercase resulting a list of string.</p>
</div>
<div class="sect3">
<h4 id="_lyre_syntax"><a class="link" href="#_lyre_syntax">4.2.1. Lyre Syntax</a></h4>
<div class="paragraph">
<p>Lyre expressions attempt to process and convert input and output types in an intelligent manner.
For example, a method that transforms an HString into a String will apply itself to each HString in List.
Note that to make these operations more explicit, you can use the <code>map</code> and <code>filter</code> commands.
Lyre is comprised of the following types of expressions (defined in <code>com.gengoai.hermes.extraction.lyre.LyreExpressionType</code>):</p>
</div>
<table class="tableblock frame-all grid-rows stripes-odd stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>PREDICATE</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A predicate expression evaluates an Object or HString for a given condition returning <strong>true</strong> or <strong>false</strong>. When the object passed in is a collection, the predicate acts as a filter over the items in the collection.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>HSTRING</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">An HString expression evaluates an Object or HString returning an HString as the result. If the resulting object is not already an HString, <code>HString.toHString(Object)</code> is called for conversion.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>STRING</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A string expression evaluates an Object or HString returning a String as the result.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>FEATURE</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A feature expression evaluates an Object or HString returning a machine learning Feature as the result.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>OBJECT</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">An object expression evaluates an Object or HString returning an object as the result (this is used for Lists).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>NUMERIC</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A numeric expression evaluates an Object or HString returning a numeric result.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>COUNTER</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A counter expression evaluates an Object or HString returning a Counter result.</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_this"><a class="link" href="#_this">This</a></h5>
<div class="paragraph">
<p>The <code>$_</code> (or this) operator represents the current object in focus, which by default is the object passed into one of the LyreExpression&#8217;s apply methods.
Note that one-argument methods in Lyre (e.g. lower, isUpper, etc.) have an implied <code>$_</code> argument if none is given.</p>
</div>
</div>
<div class="sect4">
<h5 id="_literals"><a class="link" href="#_literals">Literals</a></h5>
<div class="paragraph">
<p><strong>String Literals</strong>: Lyre allows for string literals to be specified using single quotes (').
The backslash character can be use to escape a single quote if it is required in the literal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="string"><span class="delimiter">'</span><span class="content">Orlando</span><span class="delimiter">'</span></span>
<span class="string"><span class="delimiter">'</span><span class="char">\'</span><span class="content">s</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Numeric Literals</strong>: Lyres accepts numerical literal values in the form of ints and doubles and allows for scientific notation.
Additionally, negative and positive infinity can be expressed as <code>-INF</code> and <code>INF</code> respectively and NaN as <code>NaN</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="integer">12</span>
<span class="float">1.05</span>
<span class="float">1e-5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Null</strong>: Null values are represented using the keyword <code>null</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">$</span>_ = <span class="predefined-constant">null</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Boolean Literals</strong>: Boolean values are represented as <code>true</code> and <code>false</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">isStopWord = <span class="predefined-constant">true</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_lists"><a class="link" href="#_lists">Lists</a></h5>
<div class="paragraph">
<p>A list of literals or expressions can be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">[<span class="float">1.0</span>, <span class="float">2.0</span>, <span class="float">3.0</span>]
[<span class="string"><span class="delimiter">'</span><span class="content">Orlando</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Dallas</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Phoenix</span><span class="delimiter">'</span></span>]
[lower, upper, lemma]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note when a list is the return type and the returned list would have a single item the single item is returned instead.
For example, if a method generated the list <code>[1]</code>, the value <code>1</code> would be returned instead of the list.</p>
</div>
<div class="paragraph">
<p><strong>Length</strong>: The length of a list is determined using the `llen' method as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">llen( <span class="annotation">@ENTITY</span> )</code></pre>
</div>
</div>
<div class="paragraph">
<p>where we are returning the length of the list of entities on the object in focus.</p>
</div>
<div class="paragraph">
<p><strong>List Accessors</strong>: Lyre provides three methods for accessing a list of items:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>first(LIST)</code>: Return the first element of a list expression or null if none.</p>
</li>
<li>
<p><code>last(LIST)</code>: Return the last element of a list expression or null if none.</p>
</li>
<li>
<p><code>get(LIST, INDEX)</code>: Gets the i-th element in the given list or null if the index is invalid.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code snippet illustrates using these three accessor methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">first( <span class="annotation">@ENTITY</span> ) <i class="conum" data-value="1"></i><b>(1)</b>
last( <span class="annotation">@ENTITY</span> ) <i class="conum" data-value="2"></i><b>(2)</b>
get(<span class="annotation">@TOKEN</span>, <span class="integer">10</span>) <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns the first entity overlapping the object in focus.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns the last entity overlapping the object in focus.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get the 10th token overlapping the object in focus.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>List Selectors</strong>: Lyre provides two methods for selecting the best item in a list:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>max(LIST, INDEX)</code>: Return the annotation in the list expression with maximum confidence as obtained via the <em>CONFIDENCE</em> attribute or null if none.</p>
</li>
<li>
<p><code>longest(LIST, INDEX)</code>: Return the longest (character length) element of a list expression or null if none.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code snippet illustrates using these two selection methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">max( <span class="annotation">@ENTITY</span> ) <i class="conum" data-value="1"></i><b>(1)</b>
longest( <span class="annotation">@ENTITY</span> ) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Gets the entity with maximum confidence overlapping the object in focus.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Gets the entity with longest character length overlapping the object in focus.
Note that unlike <code>max</code> the entity returned from <code>longest</code> may not be the one they system is most confident in, but instead is the one that covers the most amount of text.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>List Transforms</strong>: Lyre provides three methods of transforming a list:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>map(LIST, EXPRESSION)</code>: The map operator applies the given expression to each element of the given list.</p>
</li>
<li>
<p><code>filter(LIST, EXPRESSION)</code>: The filter operator retains items from the given list for which the given expression evaluates to <strong>true</strong>.</p>
</li>
<li>
<p><code>flatten(LIST)</code>: Flattens all elements in a list recursively.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that Lyre will create a one-item list if the list item passed in is not a collection.
The following code snippet illustrates using these three transform methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">map(<span class="annotation">@PHRASE_CHUNK</span>, lower) <i class="conum" data-value="1"></i><b>(1)</b>
filter(<span class="annotation">@TOKEN</span>, isContentWord) <i class="conum" data-value="2"></i><b>(2)</b>
flatten( map(<span class="annotation">@TOKEN</span>, [ <span class="string"><span class="delimiter">'</span><span class="content">p1=</span><span class="delimiter">'</span></span> + <span class="error">$</span>_[:-<span class="integer">1</span>], <span class="string"><span class="delimiter">'</span><span class="content">p2=</span><span class="delimiter">'</span></span> + <span class="error">$</span>_[:-<span class="integer">2</span>] ] )  ) <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lower cases each phrase chunk overlapping the current object in focus.
(Note this is the same as <code>lower(@PHRASE_CHUNK)</code>)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Keeps only the tokens overlapping the current object in focus which are content words.
(Note this is the same as <code>isContentWord(@TOKEN)</code>)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create a flattened list of unigram and bigram prefixes of all tokens on the current HString.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>List Predicates</strong>: Lyre provides three methods for testing a list based on its items:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>any(LIST, EXPRESSION)</code>: Returns <strong>true</strong> if any item in the given list evaluates to <strong>true</strong> for the given predicate expression.</p>
</li>
<li>
<p><code>all(LIST, EXPRESSION)</code>: Returns <strong>true</strong> if all items in the given list evaluates to <strong>true</strong> for the given predicate expression.</p>
</li>
<li>
<p><code>none(LIST, EXPRESSION)</code>: Returns <strong>true</strong> if none of the items in the given list evaluates to <strong>true</strong> for the given predicate expression.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that Lyre will create a one-item list if the item passed in is not a collection.
The following code snippet illustrates using these three predicate methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">any(<span class="annotation">@TOKEN</span>, isStopWord) <i class="conum" data-value="1"></i><b>(1)</b>
all(<span class="annotation">@TOKEN</span>, isContentWord) <i class="conum" data-value="2"></i><b>(2)</b>
none(<span class="annotation">@TOKEN</span>, isContentWord) <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns <strong>true</strong> if any token overlapping the object in focus is a stopword, e.g. it would evaluate to true when being tested on "the red house" and false when tested on "red house".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns <strong>true</strong> if all tokens overlapping the object in focus are content words, e.g. it would evaluate to true when being tested on "red house" and false when tested on "the red house".</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Returns <strong>true</strong> if none of the tokens overlapping the object in focus are content words, e.g. it would evaluate to true when being tested on "to the" and false when tested on "to the red house".</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_operators"><a class="link" href="#_operators">Operators</a></h5>
<div class="paragraph">
<p><strong>Logical Operators</strong>: Lyre provides a set of logical operators for and (<code>&amp;&amp;</code>), or (<code>||</code>), and xor (<code>^</code>) that can be applied to two predicate expressions.
Note that if a non-predicate expression is used it will evaluated as a predicate in which case it will return <strong>false</strong> when the object being tested is null and <strong>true</strong> when not null with the following checks for specific types of the expression being treated as a predicate:</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="1">
<li>
<p>Collection: <strong>true</strong> when non-empty, <strong>false</strong> otherwise.</p>
</li>
<li>
<p>CharSequence: <strong>true</strong> when not empty or null, <strong>false</strong> otherwise.</p>
</li>
<li>
<p>Lexicon: <strong>true</strong> when the item being tested is in the lexicon, <strong>false</strong> otherwise.</p>
</li>
<li>
<p>Number: <strong>true</strong> when the number is finite, <strong>false</strong> otherwise.</p>
</li>
<li>
<p>Part of Speech: <strong>false</strong> when the part-of-speech is "ANY" or null, <strong>true</strong> otherwise.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Negation</strong>: Lyre uses <code>!</code> to denote negation (or not) of a predicate, e.g. <code>!isLower</code>  negates the the string predicate testing for all lowercase letters, returning <strong>true</strong> if the string passed in has any non-lowercase letter.</p>
</div>
<div class="paragraph">
<p><strong>Relational Operators</strong>: Lyre provides the standard set of relational operators, <code>=</code>, <code>&lt;</code>, <code>&#8656;</code>, <code>&gt;</code>, <code>&gt;=</code>, and <code>!=</code>.
How the left-hand and right-hand sides are compared is dependent on their type.
The following table lists the comparison rules.</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>LHS Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>RHS Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Comparison</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equality and inequality perform a reference check and all other operations return false.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equality and inequality perform a reference check and all other operations return false.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NUMBER</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>NUMBER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double-based numeric comparison.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TAG</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>TAG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equality and inequality check based on <code>isInstance( Tag )</code> all other operations perform comparison based on the <code>name</code> of the tags.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TAG</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>TAG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equality and inequality check based on <code>isInstance( Tag )</code> all other operations perform comparison based on the <code>name</code> of the tags.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>instanceOf(RHS)</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>instanceOf(LHS)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Standard object-based comparison.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CharSequence</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>CharSequence</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string-based comparison.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>NOT CharSequence</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tries to convert the LHS into the type of the RHS and reapplies the rules.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT CharSequence</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tries to convert the RHS into the type of the LHS and reapplies the rules.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Pipe Operators</strong>: Lyre provides two pipe operators.
The first is the And-pipe operator <code>&amp;&gt;</code> which sequentially processes each expression with the output of the previous expression or the input object for the first expression.
All expression are evaluated regardless of whether or not a null value is encountered.
The second is the Or-pipe operator <code>|&gt;</code> which sequentially processes each expression with the input object, returning the result of the first expression that evaluates to a non-null, non-empty list, or finite numeric value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">map(<span class="annotation">@TOKEN</span>, lower &amp;&gt; s/<span class="error">\</span>d+/<span class="error">#</span>/g) <i class="conum" data-value="1"></i><b>(1)</b>
map(<span class="annotation">@TOKEN</span>, filter(<span class="error">$</span>_, isContentWord) |&gt; <span class="string"><span class="delimiter">'</span><span class="content">STOPWORD</span><span class="delimiter">'</span></span>) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Maps the tokens overlapping the object in focus first to lowercase and then for each lowercase token replaces all digits with "#".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Maps the tokens overlapping the object in focus to themselves when they are content words and to the literal value 'STOPWORD' when they are not content words.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Plus</strong>: The plus operator, <code>+</code>, can be used to concatenate strings, perform addition on numeric values, or append to a list.
Which operation is performed depends on the LHS and RHS type as follows in order:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"><strong>LHS Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>RHS Type</strong></th>
<th class="tableblock halign-center valign-middle"><strong>Comparison</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add the RHS to the collection unless the RHS is null.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>Collection</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return the RHS.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>HString</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Perform a union of the two Hstring.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NUMBER</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>NUMBER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add the two numeric values together.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return an empty list.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return the RHS.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return the LHS.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock"><code>ANY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return the concatenation of the two objects' string representation.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Membership Operators</strong>: Lyre provides to membership operators the <code>in</code> and the <code>has</code> operator.
The in operator, <code>LHS in RHS</code>, checks if the left-hand object is "in" the right-hand object, where in means "contains".
Lyre is able to handle collections, lexicons, and CharSequence as the right-hand object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span> in <span class="string"><span class="delimiter">'</span><span class="content">hat</span><span class="delimiter">'</span></span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="string"><span class="delimiter">'</span><span class="content">dog</span><span class="delimiter">'</span></span> in [<span class="string"><span class="delimiter">'</span><span class="content">cat</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">dog</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">bird</span><span class="delimiter">'</span></span>] <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns true if the character 'a' is the string 'hat'.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns true if the string 'dog' is in the given list.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The has operator, <code>LHS has RHS</code>, checks if any annotations on the LHS HString evaluates to true using the right-hand expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">$</span>_ has <span class="error">#</span>NP(<span class="annotation">@PHRASE_CHUNK</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code snippet above checks if the current HString in focus has any phrase chunks whose part-of-speech is NP (Noun Phrase).</p>
</div>
<div class="paragraph">
<p><strong>Slice Operator</strong>: Performs a slice on Strings and Collections where a slice is a sub-string or sub-list.
Slices are defined using the square brackets, <code>[</code> and <code>]</code>, with the starting (inclusive) and ending (exclusive) index separated by a colon, e.g. <code>[0:1]</code>.
The starting or ending index can be omitted, e.g. <code>[:1]</code> or <code>[3:]</code>, where the implied starting index is <em>0</em> and the implied ending index is the length of the object.
Additionally, the ending index can be given as a relative offset to the end of the item, e.g. <code>[:-2]</code> represents a slice starting at 0 to item length -2. An example of the slice operator is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">$</span>_[:-<span class="integer">1</span>] <i class="conum" data-value="1"></i><b>(1)</b>
<span class="error">$</span>_[<span class="integer">2</span>:] <i class="conum" data-value="2"></i><b>(2)</b>
[<span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">B</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>][<span class="integer">0</span>:<span class="integer">2</span>] <i class="conum" data-value="3"></i><b>(3)</b>
[<span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">B</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>][<span class="integer">0</span>:<span class="integer">4</span>] <i class="conum" data-value="4"></i><b>(4)</b>
[<span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">B</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>][<span class="integer">40</span>:] <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a substring starting at 0 and ending at the length of the string - 1.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creates a substring starting at 2 and ending at the length of the string</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creates a sub-list starting at index 0 and ending at index 2 (exclusive).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Creates a sub-list starting at index 0 and ending at index 4(exclusive).
Note that the list is of length 3 and therefore will return a copy of the entire list.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Creates a sub-list starting at index 40 and ending at the last item in the list.
Note that the list is of length 3 and therefore will return an empty list as there is no 40th item.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Length</strong>: The length in characters of the string representation of an object or the number of items in a list can be determined using the <code>len</code> method.</p>
</div>
</div>
<div class="sect4">
<h5 id="_conditional_statements"><a class="link" href="#_conditional_statements">Conditional Statements</a></h5>
<div class="paragraph">
<p><strong>If</strong>: The if-then ,<code>if( PREDICATE, TRUE_EXPRESSION, FALSE_EXPRESSION )</code>, method performs a given true or false expression based on a given condition.
The following example snippets checks if the object in focus is a digit and when it is returns the string literal <code>'[:digit:]</code> and when it is not returns the item.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">if</span>(isDigit, <span class="string"><span class="delimiter">'</span><span class="content">[:digit:]</span><span class="delimiter">'</span></span>, <span class="error">$</span>_)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>When</strong>: The when, <code>when( PREDICATE, TRUE_EXPRESSION )</code>, performs the given expression when the given condition is true and returns <strong>null</strong> when the condition is false.
The following example snippets checks if the length of the item in focus is greater than three and when it is returns the concatenation of the string literal <code>'s3='</code> and the substring/sublist starting at index 3 to the end of the item.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">when( len &gt; <span class="integer">3</span>, <span class="string"><span class="delimiter">'</span><span class="content">s3=</span><span class="delimiter">'</span></span> + <span class="error">$</span>_[-<span class="integer">3</span>:] )</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Not Null</strong>: The not null,<code>nn( EXPRESSION, DEFAULT_VALUE_EXPRESSION )</code>, returns the result of the given expression when not null and the result of the default value expression when null.
The following example snippets checks for the existence of entities on the object in focus and when there are none (the empty list is automatically converted into a null value) will return the string literal <code>'non-entity'</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">nn( <span class="annotation">@ENTITY</span>, <span class="string"><span class="delimiter">'</span><span class="content">non-entity</span><span class="delimiter">'</span></span> )</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_predicates"><a class="link" href="#_predicates">Predicates</a></h5>
<div class="paragraph">
<p><strong>Match All</strong>: The all predicate, <code>~</code>, returns <strong>true</strong> for all input.</p>
</div>
<div class="paragraph">
<p><strong>Exists</strong>: The exists predicate, <code>exists( OBJECT )</code> checks if the Object exists meaning it is not null and not a blank CharSequence or empty list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">exists(<span class="annotation">@ENTITY</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code snippet above checks if the object in focus has at least one overlapping entity returning <strong>true</strong> if it does and <strong>false</strong> otherwise.</p>
</div>
<div class="paragraph">
<p><strong>Look Behind</strong>: The positive, <code>(?&lt; &#8230;&#8203;)</code>, and negative, <code>(?!&lt; &#8230;&#8203; )</code>, look behind predicates determine if the previous annotation matches (positive) or does not match (negative) the given expression.
Note that positive and negative look behinds should be done on single HStrings or used in a list operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">(?&lt; /M[rs]<span class="error">\</span><span class="error">\</span>./g ) <span class="error">#</span>NNP <i class="conum" data-value="1"></i><b>(1)</b>
filter(<span class="annotation">@TOKEN</span>, (?&lt; /M[rs]<span class="error">\</span><span class="error">\</span>./g ) <span class="error">#</span>NNP) <i class="conum" data-value="2"></i><b>(2)</b>

(?!&lt; /M[rs]<span class="error">\</span><span class="error">\</span>./g ) <span class="error">#</span>NNP <i class="conum" data-value="3"></i><b>(3)</b>
filter(<span class="annotation">@TOKEN</span>, (?&lt; /M[rs]<span class="error">\</span><span class="error">\</span>./g ) <span class="error">#</span>NNP) <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Positive look behind returning <strong>true</strong> if the HString in focus is a proper noun and is preceded by a Mr. os Ms.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Positive look behind returning a list of tokens which are proper nouns and are preceded by Mr. or Ms.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Negative look behind returning <strong>true</strong> if the HString in focus is a proper noun and is <strong>not</strong> preceded by a Mr. os Ms.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Negative look behind returning a list of tokens which are proper nouns and are <strong>not</strong> preceded by Mr. or Ms.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Look Ahead</strong>: The positive, <code>(?&gt; &#8230;&#8203;)</code>, and negative, <code>(?!&gt; &#8230;&#8203; )</code>, look ahead predicates determine if the next annotation matches (positive) or does not match (negative) the given expression.
Note that positive and negative look aheads should be done on single HStrings or used in a list operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">#</span>NNP (?&gt; <span class="error">$</span>_ = <span class="string"><span class="delimiter">'</span><span class="content">inc.</span><span class="delimiter">'</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
filter(<span class="annotation">@TOKEN</span>, <span class="error">#</span>NNP (?&gt; <span class="error">$</span>_ = <span class="string"><span class="delimiter">'</span><span class="content">inc.</span><span class="delimiter">'</span></span>)) <i class="conum" data-value="2"></i><b>(2)</b>

<span class="error">#</span>NNP (?!&gt; <span class="error">$</span>_ = <span class="string"><span class="delimiter">'</span><span class="content">inc.</span><span class="delimiter">'</span></span>) <i class="conum" data-value="3"></i><b>(3)</b>
filter(<span class="annotation">@TOKEN</span>, <span class="error">#</span>NNP (?!&gt; <span class="error">$</span>_ = <span class="string"><span class="delimiter">'</span><span class="content">inc.</span><span class="delimiter">'</span></span>)) <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Positive look ahead returning <strong>true</strong> if the HString in focus is a proper noun and is followed by the word "inc.".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Positive look behind returning a list of tokens which are proper nouns and are followed by the word "inc.".</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Negative look behind returning <strong>true</strong> if the HString in focus is a proper noun and is <strong>not</strong> followed by the word "inc.".</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Negative look behind returning a list of tokens which are proper nouns and are <strong>not</strong> followed by the word "inc.".</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>String Matching</strong>: Lyre provides the following predicates for matching strings:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>isLower( OBJECT )</code>: Returns <strong>true</strong> if the string version of the object is all lowercase.</p>
</li>
<li>
<p><code>isUpper( OBJECT )</code>: Returns <strong>true</strong> if the string version of the object is all uppercase.</p>
</li>
<li>
<p><code>isWhitespace( OBJECT )</code>: Returns <strong>true</strong> if the string version of the object is all whitespace.</p>
</li>
<li>
<p><code>isLetter( OBJECT )</code>: Returns <strong>true</strong> if the string version of the object contains only letters.</p>
</li>
<li>
<p><code>isDigit( OBJECT )</code>: Returns <strong>true</strong> if the string version of the object contains only digits.</p>
</li>
<li>
<p><code>isAlphaNumeric( OBJECT )</code>: Returns <strong>true</strong> if the string version of the object contains only alphanumeric characters.</p>
</li>
<li>
<p><code>isPunctuation( OBJECT )</code>: Returns <strong>true</strong> if the string contains all punctuation characters.</p>
</li>
<li>
<p><code>isContentWord( OBJECT )</code>: Returns <strong>true</strong> if the string / HString is a non-stopword.</p>
</li>
<li>
<p><code>isStopWord( OBJECT )</code>: Returns <strong>true</strong> if the string / HString is a stopword.</p>
</li>
<li>
<p><code>hasStopWord( OBJECT )</code>: Returns <strong>true</strong> if the string / HString contains a stopword, i.e. any token in the HString is a stopword.</p>
</li>
<li>
<p><code>/PATTERN/<strong class="ig"></code>: Returns *true</strong> if the string / HString matches the given regular expression where the regex can have the options <code>i</code> for case-insensitive and <code>g</code> for matching the full span.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that for all methods listed above, the <code>OBJECT</code> is optional and will default to <code>$_</code> if not specified.</p>
</div>
<div class="paragraph">
<p><strong>Tag Matching</strong>: The tag predicate, <code>#TAG_VALUE( OBJECT )</code>, checks if the Tag on the object in focus is of the given Tag value.
Note that object in focus must be an annotation and the tag value needs to be convertible to that annotation&#8217;s tag type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">filter(<span class="annotation">@TOKEN</span>, <span class="error">#</span>NNP)<i class="conum" data-value="1"></i><b>(1)</b>

filter(<span class="annotation">@ENTITY</span>, <span class="error">#</span>PERSON) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Filter all tokens on the object in focus only retaining those that have a NNP part-of-speech.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Filter all entities on the object in focus only retaining those with an entity type of PERSON.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_transforms"><a class="link" href="#_transforms">Transforms</a></h5>
<div class="paragraph">
<p><strong>String transforms</strong>: Lyre provides the following methods for transforming objects into a string representation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>string( OBJECT )</code>: Transforms the input into a string by calling the <code>toString()</code> method.</p>
</li>
<li>
<p><code>lower( OBJECT )</code>: Transforms the input into a lowercase string.</p>
</li>
<li>
<p><code>upper( OBJECT )</code>: Transforms the input into an uppercase string.</p>
</li>
<li>
<p><code>lemma( OBJECT )</code>: Transforms the input into the lemmatized version.</p>
</li>
<li>
<p><code>stem( OBJECT )</code>: Transforms the input into the stemmed version.</p>
</li>
<li>
<p><code>s/pattern/replacement/[ig]*</code>: Transforms the input by performing a regular expression substitution with where the <code>i</code> option indicates a case-insensitive match and <code>g</code> indicates replace-all.
Note that this method is accessible via the LyreDSL through the <code>rsub</code> set of methods.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of the methods listed above can specified by their name only, e.g. <code>string</code>, when taking <code>$_</code> (this) as the argument.</p>
</div>
<div class="paragraph">
<p><strong>Apply transform</strong>: Lyre uses <code>LHS ~= RHS</code> to denote that the RHS expression is to be applied to the LHS expression.
This is especially useful for regular expression matching and substitution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">$</span>_ ~= /[Oo]rlando/; <i class="conum" data-value="1"></i><b>(1)</b>
<span class="annotation">@PHRASE_CHUNK</span> ~= [lower, upper] <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Applies the regular expression match as a predicate to the current object in focus.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Applies the list of Lyre expressions to each phrase chunk in the object in focus returning a List of two-element lists where the first element is the lowercase version and the second element the uppercase version of the phrase chunk.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Context Expansion</strong>: The context method, <code>cxt( HSTRING, CONTEXT_SIZE )</code>, returns a contextual (previous or next) token for the given HString at the given position (relative) where a positive value for the context size represents a next contextual token and a negative value a previous contextual token.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">cxt( <span class="error">$</span>_, -<span class="integer">1</span>) <i class="conum" data-value="1"></i><b>(1)</b>
cxt( <span class="error">$</span>_, <span class="integer">10</span>) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns the token left of the current HString.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns the token 10 to the right of the current HString.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>String Padding</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lpad( OBJECT, MINIMUM_LENGTH, PADDING_CHARACTER )</code>: Transforms the string version of the input object to ensure it is of the minimum length by prepending the padding character.</p>
</li>
<li>
<p><code>rpad( OBJECT, MINIMUM_LENGTH, PADDING_CHARACTER )</code>: Transforms the string version of the input object to ensure it is of the minimum length by appending the padding character.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that in both <code>lpad</code> and <code>rpad</code> if the given PADDING_CHARACTER has a length &gt; 1 only the first character is used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">lpad(<span class="string"><span class="delimiter">'</span><span class="content">ab</span><span class="delimiter">'</span></span>, <span class="integer">4</span>, <span class="string"><span class="delimiter">'</span><span class="content">^</span><span class="delimiter">'</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
rpad(<span class="string"><span class="delimiter">'</span><span class="content">ab</span><span class="delimiter">'</span></span>, <span class="integer">3</span>, <span class="string"><span class="delimiter">'</span><span class="content">$</span><span class="delimiter">'</span></span>) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Pads the given input literal <code>ab</code> to be of length 4 by prepending <code>^</code> resulting in <code>^^ab</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Pads the given input literal <code>ab</code> to be of length 3 by appending <code>$</code> resulting in <code>ab$</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>HString Trimming</strong>: The trim, <code>trim(HSTRING, PREDICATE)</code>, method removes tokens from the left and right of the input HString if they evaluate to true with the given predicate.
The following code snippet trims token from the input HString when they are a stopword or have a length less than three characters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">trim( <span class="error">$</span>_, isStopWord || len &lt; <span class="integer">3</span> )</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_annotatabletype_accessors"><a class="link" href="#_annotatabletype_accessors">AnnotatableType Accessors</a></h5>
<div class="paragraph">
<p><strong>Annotation Accessors</strong>: Lyre provides the following methods for accessing the annotations on an HString:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@ANNOTATION_TYPE</code>: Return a list of the annotation for the given <code>ANNOTATION_TYPE</code> overlapping the HString in focus.</p>
</li>
<li>
<p><code>@ANNOTATION_TYPE{TAG}</code>: Return a list of the annotation for the given <code>ANNOTATION_TYPE</code> overlapping the HString in focus filtered to only those whose tag is an instance of the given tag value.</p>
</li>
<li>
<p><code>interleave('ANNOTATION_TYPE', &#8230;&#8203;, 'ANNOTATION_TYPE')</code>: Return a list of the annotation for the given <code>ANNOTATION_TYPE</code> overlapping the HString in focus using the <code>HString.interleave(AnnotationType&#8230;&#8203;)</code> method.
Note that the AnnotationType names are given as string literals.</p>
</li>
<li>
<p><code>@&gt;RELATION_TYPE</code>: Retrieves a list of the annotations that are reachable via an outgoing relation for the given <code>RELATION_TYPE</code>.</p>
</li>
<li>
<p><code>@&gt;RELATION_TYPE{'RELATION VALUE'}</code>: Retrieves a list of the annotations that are reachable via an outgoing relation for the given <code>RELATION_TYPE</code> and having the given <code>RELATION_VALUE</code>.</p>
</li>
<li>
<p><code>@&gt;</code>: Retrieves a list of the annotations that are reachable via an outgoing dependency relation.</p>
</li>
<li>
<p><code>@&gt;{'DEPENDENCY_TYPE'}</code>: Retrieves a list of the annotations that are reachable via an outgoing dependency relation of given <code>DEPENDENCY_TYPE</code>.</p>
</li>
<li>
<p><code>@&lt;RELATION_TYPE</code>: Retrieves a list of the annotations that are reachable via an incoming relation for the given <code>RELATION_TYPE</code>.</p>
</li>
<li>
<p><code>@&lt;RELATION_TYPE{'RELATION VALUE'}</code>: Retrieves a list of the annotations that are reachable via an incoming relation for the given <code>RELATION_TYPE</code> and having the given <code>RELATION_VALUE</code>.</p>
</li>
<li>
<p><code>@&lt;</code>: Retrieves a list of the annotations that are reachable via an incoming dependency relation.</p>
</li>
<li>
<p><code>@&lt;{'DEPENDENCY_TYPE'}</code>: Retrieves a list of the annotations that are reachable via an incoming dependency relation of given <code>DEPENDENCY_TYPE</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that in call cases if the returned list has a single annotation, the single annotation will be returned instead.</p>
</div>
<div class="paragraph">
<p>The following code snippet shows examples of extracting annotations in Lyre.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ENTITY</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="annotation">@TOKEN</span>( <span class="annotation">@ENTITY</span> ) <i class="conum" data-value="2"></i><b>(2)</b>
<span class="error">@</span>&gt;COREFERNCE{<span class="string"><span class="delimiter">'</span><span class="content">pronominal</span><span class="delimiter">'</span></span>} <i class="conum" data-value="3"></i><b>(3)</b>
<span class="error">@</span>&lt;dep{<span class="string"><span class="delimiter">'</span><span class="content">nsubj</span><span class="delimiter">'</span></span>} <i class="conum" data-value="4"></i><b>(4)</b>
<span class="annotation">@ENTITY</span>{PERSON} <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns a list of annotations (or single annotation if only one) of the entities overlapping the object in focus, <code>$_</code>, realized as an HString using <code>HString.toHString(Object)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For each Entity annotation overlapping the object in focus, extract the tokens as a list, which results in a list of object where the object is a single annotation or list of annotations.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get all annotations reachable via an outgoing COREFERENCE relation from the object in focus where the COREFERENCE relation has the value "pronominal".</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Get all annotations reachable via an incoming dependency relation from the object in focus where the dependecy relation has the type "nsubj".</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Returns a list of annotations of the PERSON entities overlapping the object in focus.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Attributes</strong>: Lyre provides the following methods for accessing the attributes on an HString:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>$ATTRIBUTE_TYPE( OBJECT )</code>: Retrieves the value of the given <code>ATTRIBUTE_TYPE</code> on the object in focus.</p>
</li>
<li>
<p><code>pos( OBJECT )</code>: Gets the part-of-speech tag on the object in focus.</p>
</li>
<li>
<p><code>upos( OBJECT )</code>: Gets the universal part-of-speech tag on the object in focus.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>*Token Length: To determine the number of tokens in an object in focus the <code>tlen</code> method is available.</p>
</div>
</div>
<div class="sect4">
<h5 id="_lexicons_and_word_lists"><a class="link" href="#_lexicons_and_word_lists">Lexicons and Word Lists</a></h5>
<div class="paragraph">
<p><strong>Lexicons</strong>: The lexicon function, <code>%LEXICON_NAME</code>, Returns the lexicon with the given <code>LEXICON_NAME</code> using Hermes&#8217;s LexiconManager.
The returned lexicon can then be used to check of the existence of words.
The following snippet gives two examples of checking if the object in focus is in a lexicon named <code>person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">$</span>_ in %person
%person</code></pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen in the snippet above, the lexicon acts as a predicate checking for existence.</p>
</div>
<div class="paragraph">
<p><strong>Word Lists</strong>: The word list function, <code>wordList( LIST_EXPRESSION )</code>, will create a temporary word list for use.
The following code snippet shows an example of constructing a temporary word list made up of the strings "dog", "cat", and "bird" and using the constructed word list as a container to check if the object in focus&#8217;s string representation if one of the items in the word list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">$</span>_ in wordList([<span class="string"><span class="delimiter">'</span><span class="content">dog</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">cat</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">bird</span><span class="delimiter">'</span></span>])</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_feature_and_count_generators"><a class="link" href="#_feature_and_count_generators">Feature and Count Generators</a></h5>
<div class="paragraph">
<p><strong>Feature Generator</strong>: Lyre provides the following methods for easily constructing lists of features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>binary{'PREFIX'}( EXPRESSION )</code>: Converts the list of values returned by the given <code>EXPRESSION</code> into binary features prefixed with the given <code>PREFIX</code>.</p>
</li>
<li>
<p><code>binary( EXPRESSION )</code>: Converts the list of values returned by the given <code>EXPRESSION</code> into binary features.</p>
</li>
<li>
<p><code>frequency{'PREFIX'}( EXPRESSION )</code>: Converts the list of values returned by the given <code>EXPRESSION</code> into features prefixed with the given <code>PREFIX</code> whose values are number of times it occurred in the list.</p>
</li>
<li>
<p><code>frequency( EXPRESSION )</code>: Converts the list of values returned by the given <code>EXPRESSION</code> into features prefixed whose values are number of times it occurred in the list.</p>
</li>
<li>
<p><code>L1{'PREFIX'}( EXPRESSION )</code>: Converts the list of values returned by the given <code>EXPRESSION</code> into features prefixed with the given <code>PREFIX</code> whose values are number of times it occurred in the list divided by the total number of items in the list.</p>
</li>
<li>
<p><code>L1( EXPRESSION )</code>: Converts the list of values returned by the given <code>EXPRESSION</code> into features whose values are number of times it occurred in the list divided by the total number of items in the list.</p>
</li>
<li>
<p><code>iob( 'ANNOTATION_TYPE' )</code>: Generates IOB-formatted tags for the given <code>ANNOTATION_TYPE</code> overlapping the object in focus.</p>
</li>
<li>
<p><code>iob( 'ANNOTATION_TYPE', OBJECT )</code>: Generates IOB-formatted tags for the given <code>ANNOTATION_TYPE</code> overlapping the given OBJECT.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">binary{<span class="string"><span class="delimiter">'</span><span class="content">WORD</span><span class="delimiter">'</span></span>}(<span class="annotation">@TOKEN</span>)<i class="conum" data-value="1"></i><b>(1)</b>
frequency{<span class="string"><span class="delimiter">'</span><span class="content">WORD</span><span class="delimiter">'</span></span>}(<span class="annotation">@TOKEN</span>)<i class="conum" data-value="2"></i><b>(2)</b>
K1{<span class="string"><span class="delimiter">'</span><span class="content">WORD</span><span class="delimiter">'</span></span>}(<span class="annotation">@TOKEN</span>)<i class="conum" data-value="3"></i><b>(3)</b>
iob(<span class="string"><span class="delimiter">'</span><span class="content">PHRASE_CHUNK</span><span class="delimiter">'</span></span>, <span class="annotation">@SENTENCE</span>) <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Generates a list of binary features containing the string form of the tokens overlapping the object in focus with a 'WORD' prefix.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Generates a list of features with frequency counts containing the string form of the tokens overlapping the object in focus with a 'WORD' prefix.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Generates a list of features with L1 normalized frequency counts containing the string form of the tokens overlapping the object in focus with a 'WORD' prefix.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Generates iob formatted chunk part-of-speech tags over the sentences overlapping the object in focus.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Count Generator</strong>: Lyre provides the following methods for easily creating Counters over lists of items:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>count( EXPRESSION, 'VALUE_CALCULATOR' )</code>, counts the items in the list obtained from given <code>EXPRESSION</code> converting the values using the <em>ValueCalculator</em> corresponding to the given literal value <code>'VALUE_CALCULATOR'</code>.</p>
</li>
<li>
<p><code>count( EXPRESSION )</code>, counts the frequency of the items in the list obtained from given <code>EXPRESSION</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="keywords"><a class="link" href="#keywords">4.3. Keyword Extraction</a></h3>
<div class="paragraph">
<p>Keyword extraction is the processing of identify key phrases or concepts that a document or collection of document is discussing.
There are a number of methods defined for extracting keywords in the NLP literature that range from simple phrase counting to machine learning models that extract phrases from a controlled vocabulary.
In general, the various keyword extraction methodologies have a combination of the follow characteristics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Unsupervised</strong> or <strong>Supervised</strong>: Much like machine learning keyword extraction be done in an supervised fashion, often learning a mapping between documents and a controlled vocabulary, or an unsupervised fashion, often in which phrase and corpus statistics are used to determine the importance of phrases.</p>
</li>
<li>
<p><strong>Single Document</strong> or <strong>Corpus</strong>: Many of the early approaches to keyword extraction relied on corpus level statistics and thus keywords could only be generated given a corpus.
Newer approaches allow for keyword extraction from a single document where corpus level statistics are not required.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Hermes all keyword extraction methods implement the <em>KeywordExtactor</em> interface which is an <em>Extractor</em> with the addition of a <code>fit(corpus)</code> method.
The <code>fit</code> method is used when corpus level statistics are needed in order to perform keyword extraction or when keyword extraction is performed in a supervised manner.</p>
</div>
<div class="paragraph">
<p>Hermes provides the following keyword extractor implementations:</p>
</div>
<table class="tableblock frame-all grid-all stripes-odd stretch">
<colgroup>
<col style="width: 66.6666%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code><strong>Class Name</strong></code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><strong>Requires Fit</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermKeywordExtractor</code></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Extracts a set of keywords based on term frequency using an underlying <em>FeautrizingExtractor</em>, such as a Lyre expression.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TFIDFKeywordExtractor</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>Extracts a set of keywords based on term frequency inverse document frequency (TFIDF) using an underlying <em>FeautrizingExtractor</em>, such as a Lyre expression. The call to the <code>fit(corpus)</code> method is used to calculate the document frequencies of the terms in the corpus</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RakeKeywordExtractor</code></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>An implementation of the RAKE algorithm <em>Rose, S., Engel, D., Cramer, N., &amp; Cowley, W. (2010). Automatic Keyword Extraction from Individual Documents. In M. W. Berry &amp; J. Kogan (Eds.), Text Mining: Theory and Applications: John Wiley &amp; Sons.</em>. Rake extracts contiguous spans of text which do not contain stopwords as candidate keywords and scores the candidates based on their order and frequency.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NPClusteringKeywordExtractor</code></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="2"><div class="content"><div class="paragraph">
<p>An implementation of the keyword extractor defined in <em>Bracewell, David B., Yan, Jiajun, and Ren, Fuji, (2008), Single Document Keyword Extraction For Internet News Articles, International Journal of Innovative Computing, Information and Control, 4, 905—913</em>. The algorithm extracts noun phrases as candidate keywords and then clusters the noun phrases into semantically coherent groups. These groups are scored and the central noun phrase of the group is then used as a keyword with the group&#8217;s score as its own.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="tokenre"><a class="link" href="#tokenre">4.4. Token-Based Regular Expressions</a></h3>
<div class="paragraph">
<p>Hermes provides a token-based regular expression engine that allows for matches on arbitrary annotation types, relation types, and attributes, while providing many of the operators that are possible using standard Java regular expressions.
As with Java regular expressions, the token regular expression is specified as a string and is compiled into an instance of of <em>TokenRegex</em>.
The <em>TokenRegex</em> class has many of the same methods as Java&#8217;s regular expression, but returns a <em>TokenMatcher</em> instead of Matcher.
The <em>TokenMatcher</em> class allows for iterating of the matches, extracting the match or named-groups within the match, the starting and ending offset of the match, and conversion into a <em>TokenMatch</em> object which records the current state of the match.
Token regular expressions can act as extractors where the extraction generates the HStrings matched for the default group.
An example of compiling a regular expression, creating a match, and iterating over the matches is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">TokenRegex regex = TokenRegex.compile(pattern);
TokenMatcher matcher = regex.matcher(document);
<span class="keyword">while</span> (matcher.find()) {
        <span class="predefined-type">System</span>.out.println(matcher.group());
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_regular_expression_syntax"><a class="link" href="#_regular_expression_syntax">4.4.1. Regular Expression Syntax</a></h4>
<div class="paragraph">
<p>The syntax for token-based regular expressions borrows from the <a href="#lyre">Lyre Expression Language</a> where possible.
Token-based regular expressions differ from Lyre in that they work over sequences of HStrings whereas Lyre is working on single HString units.
As such, there are differences in the syntax between Lyre.</p>
</div>
<div class="sect4">
<h5 id="_content_matching"><a class="link" href="#_content_matching">Content Matching</a></h5>
<div class="paragraph">
<p>Content can be matched in the following manner:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Any</strong>: The <code>.</code> operator can be used to match any HString.</p>
</li>
<li>
<p><strong>Case-Sensitive String Match</strong>: Matches based on a case-sensitive match to the string form of the HString, expressed using double quotes, e.g. <code>"ABC"</code>.</p>
</li>
<li>
<p><strong>Case-Insensitive String Match</strong>: Matches based on a case-insensitive match to the string form of the HString, expressed using single quotes, e.g. <code>'ABC'</code>.</p>
</li>
<li>
<p><strong>Lemmatized String Match</strong>: Matches based on a case-insensitive match to the lemmatized form of the HString, expressed using the less than and greater signs, e.g. <code>&lt;ABC&gt;</code>.</p>
</li>
<li>
<p><strong>Lexicon Match</strong>: Matches against a lexicon can be made by expressing the name of the lexicon to match against using <code>%LEXICON_NAME</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>"Orlando" <i class="conum" data-value="1"></i><b>(1)</b>
'orlando' <i class="conum" data-value="2"></i><b>(2)</b>
&lt;fly&gt; <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Case-sensitive match in which only HStrings containing only the word "Orlando" are matched.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Case-insensitive match in which all capitalization variations of the word "orlando" are matched.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Case-insensitive match in which all HString whose lemmatized is "fly" will be matched (e.g., "flies", "flew", and "flown").</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_word_classes"><a class="link" href="#_word_classes">Word Classes</a></h5>
<div class="paragraph">
<p>The following word classes are defined:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AlphaNumeric</code>: Matches HStrings whose string form contains only alphanumeric characters.</p>
</li>
<li>
<p><code>ContentWord</code>: Matches HStrings which are content words, i.e. non-stopwords.</p>
</li>
<li>
<p><code>HasStopWord</code>: Matches HStrings which contain on or more stopwords.</p>
</li>
<li>
<p><code>StopWord</code>: Matches HStrings which are stopwords.</p>
</li>
<li>
<p><code>Upper</code>: Matches HStrings whose string form contains only uppercase letters.</p>
</li>
<li>
<p><code>UpperInitial</code>: Matches HStrings whose first character is an uppercase letter.</p>
</li>
<li>
<p><code>Lower</code>: Matches HStrings whose string form contains only lower letters.</p>
</li>
<li>
<p><code>LowerInitial</code>: Matches HStrings whose first character is a lowercase letter.</p>
</li>
<li>
<p><code>Letter</code>: Matches HStrings whose string form contains only letters.</p>
</li>
<li>
<p><code>Digit</code>: Matches HStrings whose string form contains only digits.</p>
</li>
<li>
<p><code>Number</code>: Matches HStrings which represents numbers as ascertained by their <code>TOKEN_TYPE</code> or <code>PART_OF_SPEECH</code> attribute or whose string form contains only digits.</p>
</li>
<li>
<p><code>Punctuation</code>: Matches HStrings whose string form contains only punctuation.</p>
</li>
<li>
<p><code>/PATTERN/[ig]*</code>: Matches HStrings whose string form matches the given regular expression where the regex can have the options <code>i</code> for case-insensitive and <code>g</code> for matching the full span.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_attributes"><a class="link" href="#_attributes">Attributes</a></h5>
<div class="paragraph">
<p>Token-based regular expressions allow for matching of attribute values including numeric comparisons for number-valued attributes.
The first set of attribute-based matching will match non-numeric attributes, such as strings and tags.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$PART_OF_SPEECH = 'NOUN' <i class="conum" data-value="1"></i><b>(1)</b>
$PART_OF_SPEECH != 'NOUN' <i class="conum" data-value="2"></i><b>(2)</b>
$COLLECTION ~ 'VALUE' <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Equality check where tag-valued attributes are match if the value of the attribute is an instance of the tag defined on the right-hand side and non-tag valued attributes are match if the value of the left-hand side is equal to the value on the right-hand side.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Inequality check where tag-valued attributes are match if the value of the attribute is <strong>not</strong> an instance of the tag defined on the right-hand side and non-tag valued attributes are match if the value of the left-hand side is <strong>not</strong> equal to the value on the right-hand side.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Containment check where a match is made when the value on the right-hand side is in the collection of values associated with the attribute or is a substring of the string value of the left-hand side.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Additionally, the full range of numeric comparisons are available:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$CONFIDENCE = 0.0
$CONFIDENCE != 0.0
$CONFIDENCE &gt;= 0.50
$CONFIDENCE &gt; 0.50
$CONFIDENCE &lt;= 0.50
$CONFIDENCE &lt; 0.50</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Tags</strong>: Tag attributes can be easily matched using <code>#TAG_VALUE</code>, e.g. <code>#NOUN</code> for tokens would match all tokens whose part-of-speech is a noun.</p>
</div>
<div class="paragraph">
<p><strong>Categories</strong>: Whether or not an HString or one of its sub-spans contains a given category value can be expressed using <code>$CATEGORY ~ 'VALUE'</code> or <code>$CAT ~ 'VALUE'</code> where the VALUE must be predefined <em>BasicCategory</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_annotations"><a class="link" href="#_annotations">Annotations</a></h5>
<div class="paragraph">
<p>Matches can include the existence of annotations including optional constraints on the match.
Annotations are declared using <code>@ANNOTATION_TYPE</code> and constraints can be specified using parenthesis, i.e. <code>@ANNOTATION_TYPE(&#8230;&#8203;)</code>.
The following code snippet gives examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>@ENTITY( $CONFIDENCE &gt;= 0.90 ) <i class="conum" data-value="1"></i><b>(1)</b>
@PHRASE_CHUNK( #NP ) @PHRASE_CHUNK( #VP ) @PHRASE_CHUNK( #NP ) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Match all entities with a confidence value of 0.90 or more.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Match sequences of phrase chunks in the form NP VP NP</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
That the syntax of matching with annotations is backwards compared to Lyre.
In Lyre, the first example in the snippet above would be expressed as <code>$CONFIDENCE(@ENTITY) &gt;= 0.90</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_relations"><a class="link" href="#_relations">Relations</a></h5>
<div class="ulist">
<ul>
<li>
<p><code>@&lt;RELATION_TYPE</code>: Retrieves a the annotations that are reachable via an incoming relation of the given type.</p>
</li>
<li>
<p><code>@&lt;RELATION_TYPE{'RELATION_VALUE'}</code>: Retrieves a the annotations that are reachable via an incoming relation of the given type and having the given relation value.</p>
</li>
<li>
<p><code>@&gt;RELATION_TYPE</code>: Retrieves a the annotations that are reachable via an outgoing relation of the given type.</p>
</li>
<li>
<p><code>@&gt;RELATION_TYPE{'RELATION_VALUE'}</code>: Retrieves a the annotations that are reachable via an outgoing relation of the given type and having the given relation value.</p>
</li>
<li>
<p><code>@&lt;</code>: Retrieves a the annotations that are reachable via an incoming dependency relation.</p>
</li>
<li>
<p><code>@&lt;{'DEPENDENCY_TYPE'}</code>: Retrieves a the annotations that are reachable via an incoming dependency relation and having the given <code>DEPENDENCY_TYPE</code>.</p>
</li>
<li>
<p><code>@&gt;</code>: Retrieves a the annotations that are reachable via an outgoing dependency relation.</p>
</li>
<li>
<p><code>@&gt;{'DEPENDENCY_TYPE'}</code>: Retrieves a the annotations that are reachable via an outgoing dependency relation and having the given <code>DEPENDENCY_TYPE</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>@PHRASE_CHUNK &amp; @&gt;{'nsubj'} <i class="conum" data-value="1"></i><b>(1)</b>
@&lt;ROLE{'AGENT'}( @ENTITY( #PERSON ) ) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Match all phrase chunks that have the 'nsubj' dependency relation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Match all HString which have an incoming "ROLE" relation with value "AGENT" and whose "AGENT" is an entity of type PERSON</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_greedy_qualifiers"><a class="link" href="#_greedy_qualifiers">Greedy Qualifiers</a></h5>
<div class="paragraph">
<p>The following set of greedy qualifiers are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Kleene Star</strong>: The <code>*</code> unary operator will match zero or more of the previously defined expression, e.g. <code>'abc'*</code> will match zero or more HString whose string form is a case-insensitive match to "abc".</p>
</li>
<li>
<p><strong>Kleene Plus</strong>: The <code>+</code> unary operator will match one or more of the previously defined expression, e.g. <code>'abc'+</code> will match one or more HString whose string form is a case-insensitive match to "abc".</p>
</li>
<li>
<p><strong>Optional Marker</strong>: The <code>?</code> unary operator denotes that previous expression is optional, i.e. matches zero or one, , e.g. <code>'abc'?</code> will match if the previous HString is empty or whose string form is a case-insensitive match to "abc".</p>
</li>
<li>
<p><strong>Range Operator</strong>: A variable number of matches can be expressed using the range operator, denoted using <code>{minimum,maximum}</code>, where the maximum can be omitted to denote matching an exact number of times, have the value "*" denoting any number of maximum matches, or given numeric value expression the maximum number of matches.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_logical_operators"><a class="link" href="#_logical_operators">Logical Operators</a></h5>
<div class="paragraph">
<p>Hermes&#8217;s token-based regular expressions also supports the following logical operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Negation</strong>: The <code>^</code> operator denotes negation matching only when the next expression evaluates to true.</p>
</li>
<li>
<p><strong>Alternations</strong>: Alternations can be expressed using <code>|</code> and act as an <strong>or</strong> on the matching, e.g. <code>('cat'|'dog')</code> would match either "cat" or "dog".</p>
</li>
<li>
<p><strong>And</strong>: Ands can be expressed using <code>&amp;</code> and require both the left-hand and right-hand sides to evaluate to true for the current HString in order for it to match, e.g. <code>@ENTITY(#PERSON &amp; $CONFIDENCE &gt;0.6)</code> would match entities which are only of type PERSON and have a confidence greater than 0.6.</p>
</li>
<li>
<p><strong>Non-Capturing Groups</strong>: Non-capturing groups are used to force the order of operation and are denoted using parenthesis, e.g. <code>^('man' 'of')</code> matches any two HStrings which whose sequence is not equal to "man of".</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_special_constructs"><a class="link" href="#_special_constructs">Special Constructs</a></h5>
<div class="paragraph">
<p>The following special constructs are supported:</p>
</div>
<div class="paragraph">
<p><strong>Look Behind</strong>: The positive, <code>(?&lt; &#8230;&#8203;)</code>, and negative, <code>(?!&lt; &#8230;&#8203; )</code>, look behind predicates determine if the previous annotation sequences matches (positive) or does not match (negative) the given expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>(?&lt; 'manager' 'of' ) @PHRASE_CHUNK(#NOUN)
(?!&lt; #DT | #ADJECTIVE ) &lt;bank&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first expression, from the snippet above, matches noun phrases which are preceded by the phrase "manager of".
The second example, matches all HStrings whose lemmatized form is "bank" and are not preceded by a determiner or adjective.</p>
</div>
<div class="paragraph">
<p><strong>Look Ahead</strong>: The positive, <code>(?&gt; &#8230;&#8203;)</code>, and negative, <code>(?!&gt; &#8230;&#8203; )</code>, look ahead predicates determine if the next annotation sequence matches (positive) or does not match (negative) the given expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>PHRASE_CHUNK( #NOUN ) (?&gt; PHRASE_CHUNK(#VERB) )
Digit (?!&gt; Punctuation )</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first expression, from the snippet above, matches noun phrases which are followed by verb phrases.
The second example, matches all HStrings which represent Digits and are not followed by punctuation.</p>
</div>
<div class="paragraph">
<p><strong>Named Groups</strong>: Named groups can specified using <code>(?&lt;NAME&gt; &#8230;&#8203;)</code>.
The groups captured HString is accessed using <code>TokenMatcher.group(String)</code> where the String is the group name.
The following example illustrates a named group:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>(?&lt;PERSON&gt; @ENTITY(#PERSON))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Backreference</strong>: Backreference to named groups is possible using <code>\GROUP_NAME</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>(?&lt;PERSON&gt; @ENTITY(#PERSON)) .* PHRASE_CHUNK(#VERB &amp; @&lt;{'nsubj'}(\PERSON))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example snippet above matches all sequences in which a person entity is followed by a distant verb phrase for which the the nsubj is the matched person entity.
Note that the backreference will match when there is overlap of between the HString in the named group and the HString being examined for the backreference.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="💡"></i>
</td>
<td class="content">
Take a look at <strong>TokenRegexExample.java</strong> in the Hermes examples project to see example patterns.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caduceus"><a class="link" href="#caduceus">4.5. Caduceus</a></h3>
<div class="paragraph">
<p>Caduceus, pronounced <strong>ca·du·ceus</strong>, is a rule-based information extraction system.
Caduceus programs consist of a list of rules for extracting arbitrary spans of text to define annotations (e.g. entities and events) and relations (e.g. event roles).
Each rule starts with a unique name declared in square brackets, e.g. <code>[my_rule]</code>.
Following the rule name is the <strong>trigger</strong>, which is a <a href="#tokenre">Token-Based Regular Expressions</a> that captures the text causing the rule to fire.
Example triggers are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>trigger: (&lt;man&gt; | &lt;woman&gt; | &lt;child&gt; | &lt;baby&gt;) <i class="conum" data-value="1"></i><b>(1)</b>
trigger: (?&lt;PERSON&gt; @ENTITY(#PERSON)) (?&lt;ACTION&gt; @PHRASE_CHUNK(#VERB)) (?&lt;OBJECT&gt; @PHRASE_CHUNK(#NOUN)) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A simple trigger that fires for HStrings whose lemmatized form match one of the given lemmas.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A trigger that requires a PERSON entity followed by verb phrase followed by a noun phrase, which each item being a named group.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Rules construct annotations and/or relations based on the matched trigger.
A rule may have define zero or more annotations to be constructed.
Each annotation is defined using <code>annotation:</code> and requires the following options to be specified:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>capture=(*|GROUP_NAME)</code>: The text span which will make up the annotation, where <code>\*</code> represents the full trigger match and <code>GROUP_NAME</code> represents a named group from the trigger match.</p>
</li>
<li>
<p><code>type=ANNOTATION_TYPE</code>: The name of the annotation type to construct.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, attributes can be defined using as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ATTRIBUTE_NAME = VALUE</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example of a rule to create ENTITY annotations of type PERSON and BODY_PART is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>//###################################################################################
// Entity: PERSON - Identifies PERSON entities from Alice in Wonderland
//###################################################################################
[person]
trigger: ('alice' | 'rabbit' | ('white' 'rabbit') | ('mad' 'hatter') )
annotation: capture=*
            type=ENTITY
            $ENTITY_TYPE=PERSON
            $CONFIDENCE=1.0</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>//###################################################################################
// Entity: BODY_PART - Identifies body part entities.
//###################################################################################
[body_parts]
trigger: ( (&lt;eye&gt; | &lt;ear&gt; | &lt;arm&gt; | &lt;leg&gt; | &lt;head&gt;) &amp;&amp; #NOUN )
annotation: capture=*
            type=ENTITY
            $ENTITY_TYPE=BODY_PART
            $CONFIDENCE=1.0</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Comments are specified using <code>//</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A rule may have define zero or more relations to be constructed.
Each relation is defined using <code>relation: NAME</code>, where NAME is unqiue in the rule.
Relations require the following options to be specified:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>type=RELATION_TYPE</code>: The name of the relation type to construct.</p>
</li>
<li>
<p><code>value=STRING</code>: The value of the relation type.</p>
</li>
<li>
<p><code>@&gt;</code>: The source of the relation specified using a <a href="#lyre">Lyre Expression Language</a> with an optional named matching group defined like <code>@&gt;{GROUP_NAME}</code></p>
</li>
<li>
<p><code>@&lt;</code>: The target of the relation specified using a <a href="#lyre">Lyre Expression Language</a> with an optional named matching group defined like <code>@&gt;{GROUP_NAME}</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, a relation can be defined as <em>bidirectional</em> by specifying <code>bidirectional=true</code>.
An example of a rule to create a HAS_A relation between a PERSON and BODY_PART is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>//###################################################################################
// Relation: HAS_A - Relates a BODY_PART to a PERSON
//###################################################################################
[body_part_attributes]
trigger: (?&lt;PERSON&gt; @ENTITY(#PERSON)) "with" .{1,3} (?&lt;BODY_PART&gt; @ENTITY( #BODY_PART ))
relation:  has_a
           type=ATTRIBUTE
           value= HAS_A
           @&gt;{PERSON}=@ENTITY
           @&lt;{BODY_PART}=@ENTITY</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example rule listed above, we define a trigger that matches a PERSON entity followed by the word "with" followed by between one to three tokens, and finally followed by a BODY_PART entity.
The relation definition for HAS_A is named <code>has_a</code> and defines an ATTRIBUTE relation with value HAS_A where the source of the relation is the PERSON entity and the target of the relation is the BODY_PART entity.</p>
</div>
<div class="paragraph">
<p>In order to prevent superfluous matches, annotations and relations can have requirements on each other specified using a <code>requires</code> statement.
The use of requires can be seen in the following example rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>//###################################################################################
// Murder - The killing of one person by another
// Roles:
//    KILLER - The PERSON performing the murder
//    VICTIM - The PERSON being murdered
//    MANNER - The way in which the murder was performed
//###################################################################################
[murder]
trigger: (?&lt;EVENT&gt; &lt;murder&gt; | &lt;kill&gt; | &lt;shoot&gt; | &lt;stab&gt; | &lt;poison&gt; )
annotation: capture=*
				type=EVENT
				$TAG=MURDER
				$CONFIDENCE=1.0
				requires=VICTIM
                requires=KILLER
relation: KILLER
			 type=ROLE
			 value=KILLER
			 @&gt;=@ENTITY{PERSON}(@&lt;dep{'nsubj'})
			 @&lt;=$_
relation: VICTIM
			 type=ROLE
			 value=VICTIM
			 @&gt;=@ENTITY{PERSON}(@&lt;dep{'dobj'})
			 @&lt;=$_
relation: MANNER
			 type=ROLE
			 value=MANNER
			 @&gt;=@&lt;dep{'advmod'}
			 @&lt;=$_</code></pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen in the rule listed above, the MURDER event will only be created when a KILLER role and VICTIM role can be specified.</p>
</div>
<div class="sect3">
<h4 id="_rule_processing_and_execution"><a class="link" href="#_rule_processing_and_execution">4.5.1. Rule Processing and Execution</a></h4>
<div class="paragraph">
<p>Rules are processed sequentially starting at the first defined rule in a Caduceus program file.
This allows rules to be split apart with each being as simple as possible.
Please note that Caduceus is not designed for blazing performance, but for ease of use.</p>
</div>
<div class="paragraph">
<p>Caduceus programs can be executed over corpora or single documents as the following code snippet illustrates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">CaduceusProgram events = CaduceusProgram.read(Resources.from(<span class="string"><span class="delimiter">&quot;</span><span class="content">/data/caduceus/events.cg</span><span class="delimiter">&quot;</span></span>));

Corpus corpus = ...;
corpus.update(events); <i class="conum" data-value="1"></i><b>(1)</b>

<span class="predefined-type">Document</span> document = ...;
events.execute(document); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Caduceus programs can be executed over a corpus using the corpus <code>update(CaduceusProgram)</code> method.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Individual documents can be processed by calling the <code>execute(Document)</code> method on the CaduceusProgram.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="💡"></i>
</td>
<td class="content">
Take a look at <strong>CaduceusExample.java</strong> in the Hermes examples project to see a complete example.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_machine_learning"><a class="link" href="#_machine_learning">5. Machine Learning</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Machine learning is commonly used for providing annotations and relations, determining the value of an attribute for a document or annotation, or determining the topics discussed in a corpus.
Training of these types of machine learning models is done from a corpus.
In the case of supervised learning the corpus contains the gold standard, or correct, annotations, relations, or attributes.
Herme’s Corpus class makes it easy to construct (see asLabeledStream, asClassificationDataSet, asRegressionDataSet, and asSequenceDataSet in the Javadoc) an Apollo dataset which various machine learning algorithms can be trained or applied.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="💡"></i>
</td>
<td class="content">
Take a look at <strong>GettingStarted.java</strong>, <strong>CorpusExample.java</strong>, <strong>MLExample.java</strong>, and <strong>SparkExample.java</strong> in the Hermes examples project to see a complete example.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="workflows"><a class="link" href="#workflows">6. Workflows</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>A workflow represents a set of <em>actions</em> to perform on an document collection.
Actions fall into one or more of the following three categories:</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="1">
<li>
<p>Modify - The action modifies the documents in the collection, e.g. adds new annotations or attributes.</p>
</li>
<li>
<p>Compute - The action generates information that is added to the <em>Context</em> for use by downstream actions.</p>
</li>
<li>
<p>Output - The action generates an output for consumption by external processes and/or downstream actions.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Actions share a common key-value memory store, called a <em>Context</em>, in which information they require or they generate can be added.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/seq-workflow.png" alt="seq workflow" width="300px" height="252">
</div>
<div class="title">Figure 5. Example of Sequential Workflow</div>
</div>
<div class="paragraph">
<p>The figure illustrated above gives an example of a sequential workflow where an document collection is passed through a series of three actions each of which update (Modify) the collection and the context. The <a href="#workflow_runner">Workflow Runner</a> the can save the final output to file.</p>
</div>
<div class="sect2">
<h3 id="_contexts"><a class="link" href="#_contexts">6.1. Contexts</a></h3>
<div class="paragraph">
<p>Contexts are a specialized map that act as a shared memory for a Workflow.
The context will retrieve values from its internal storage and also fallback to checking for values in the global configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="_actions"><a class="link" href="#_actions">6.2. Actions</a></h3>
<div class="paragraph">
<p>An action defines a processing step to perform on a <em>DocumentCollection</em> with a given <em>Context</em> which results in either modifying the corpus or the context.
Action implementations can persist their state to be reused at a later time including across jvm instances and runs.
This is done by implementing the <code>loadPreviousState(DocumentCollection,Context)</code> method to modify the corpus and/or context based on its saved state.
An action can ignore its state and reprocess the corpus when either the config setting <code>processing.override.all</code> is set to true or the config setting <code>className.override</code> is set tp true.</p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_a_workflow"><a class="link" href="#_defining_a_workflow">6.3. Defining a Workflow</a></h3>
<div class="paragraph">
<p>Workflows are defined using Json.
The follow is an example definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>  : <span class="string"><span class="delimiter">&quot;</span><span class="content">Sequential</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">context</span><span class="delimiter">&quot;</span></span>: {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">alpha</span><span class="delimiter">&quot;</span></span>: {<span class="key"><span class="delimiter">&quot;</span><span class="content">@class</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">double</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">@value</span><span class="delimiter">&quot;</span></span>: <span class="float">0.2</span>}
  },
  <span class="key"><span class="delimiter">&quot;</span><span class="content">beans</span><span class="delimiter">&quot;</span></span> : {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">ANNOTATOR</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">@singleton</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">@class</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">com.gengoai.hermes.workflow.actions.Annotate</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">types</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">${CORE_ANNOTATIONS}</span><span class="delimiter">&quot;</span></span>
      }
  },
  <span class="key"><span class="delimiter">&quot;</span><span class="content">actions</span><span class="delimiter">&quot;</span></span>: [
      <span class="string"><span class="delimiter">&quot;</span><span class="content">@ANNOTATOR</span><span class="delimiter">&quot;</span></span>,
      {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">@class</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">com.gengoai.hermes.workflow.actions.TermCounts</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">extractor</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">lower(filter(@TOKEN,isContentWord))</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">documentFrequencies</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span>
      }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each workflow json must specify the workflow type (currently only Sequential workflows are supported).
An initial set of key-value pairs can be specified in the "context" section.
Note that its require to specify values as json objects in the format <code>{"@class":"java class name", "@value": value}</code>.
The json format allows for reusable beans to be defined in the "beans" section.
The bean format uses the bean name as the key for a json object which is made up of a  "@class" property to define the fully qualified class name, "@singleton" to optionally define the object as a singleton, and all setters are defined as properties in the object, e.g. "types" relates to the <code>setTypes</code> method of the Annotate action.
Finally the set of actions are defined as an array within the "actions" object.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hermes_applications"><a class="link" href="#hermes_applications">7. Hermes Applications</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="workflow_runner"><a class="link" href="#workflow_runner">7.1. Workflow Runner</a></h3>

</div>
<div class="sect2">
<h3 id="_annotate"><a class="link" href="#_annotate">7.2. annotate</a></h3>

</div>
<div class="sect2">
<h3 id="_csv2lexicon"><a class="link" href="#_csv2lexicon">7.3. csv2Lexicon</a></h3>
<div class="paragraph">
<p>The <strong>csv2Lexicon</strong> application converts a csv file containing lexical information into a Hermes lexicon.
The application has the following command line options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>csv</strong>: The csv lexicon specification.</p>
</li>
<li>
<p><strong>lexicon</strong>: The output lexicon specification.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An example command line is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="bash">csv2Lexicon --csv lexicon:mem:adhoc:csv::/data/test/import.csv;probability=-1;constraint=2;caseSensitive=true;tagAttribute=ENTITY_TYPE;defaultTag=PERSON --lexicon lexicon:disk:adhoc::/data/test/adhoc.lexicon</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. See the Mango User Guide for details on the Graph data structure.
</div>
</div>
<div id="footer">
<div id="footer-text">
Version v1.0<br>
Last updated 2020-04-10 13:55:33 -0500
</div>
</div>
</body>
</html>